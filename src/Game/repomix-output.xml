This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
AddressManager.cpp
AddressManager.h
Camera.cpp
Camera.h
GameEnums.h
HavokEnums.h
HavokOffsets.h
MumbleLink.h
MumbleLinkManager.cpp
MumbleLinkManager.h
offsets.h
ReClass/AgentStructs.h
ReClass/CharacterStructs.h
ReClass/ContextStructs.h
ReClass/EquipmentStructs.h
ReClass/GadgetStructs.h
ReClass/HavokStructs.h
ReClass/ItemStructs.h
ReClass/StatStructs.h
ReClassStructs.h
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AddressManager.cpp">
#include "AddressManager.h"

#include <windows.h>
#include <psapi.h>

#include "../Core/Config.h" // For TARGET_PROCESS_NAME
#include "../Utils/DebugLogger.h"
#include "../Utils/PatternScanner.h"
#include "ReClassStructs.h" // For ContextCollection and ChCliContext

namespace kx {

// Define the single static instance of the GamePointers struct.
GamePointers AddressManager::s_pointers;

// A helper function to resolve RIP-relative addresses (like in LEA, MOV, and CALL instructions)
uintptr_t ResolveRelativeAddress(uintptr_t instructionAddress, size_t instructionSize) {
    if (!instructionAddress || instructionSize < AddressingConstants::RELATIVE_OFFSET_SIZE) return 0;
    // The relative offset is read from the last 4 bytes of the instruction.
    int32_t relativeOffset = *reinterpret_cast<int32_t*>(instructionAddress + (instructionSize - AddressingConstants::RELATIVE_OFFSET_SIZE));
    // The address is calculated from the instruction *after* the current one.
    return instructionAddress + instructionSize + relativeOffset;
}

void AddressManager::SetContextCollectionPtr(void* ptr)
{
    s_pointers.pContextCollection.store(ptr, std::memory_order_release);
}

void AddressManager::ScanAgentArray() {
    std::optional<uintptr_t> avContextFuncOpt = PatternScanner::FindPattern(
        std::string(AGENT_VIEW_CONTEXT_PATTERN),
        std::string(TARGET_PROCESS_NAME)
    );

    if (!avContextFuncOpt) {
        LOG_ERROR("[AddressManager] AgentViewContext pattern not found.");
        s_pointers.agentArray = 0;
        return;
    }

    uintptr_t avContextFuncAddr = *avContextFuncOpt;
    LOG_INFO("[AddressManager] Found AgentViewContext at: 0x%p", (void*)avContextFuncAddr);

    std::optional<uintptr_t> leaInstructionOpt = PatternScanner::FindPattern(std::string(AGENT_ARRAY_LEA_PATTERN), avContextFuncAddr, AddressingConstants::AGENT_ARRAY_SEARCH_RANGE);

    if (!leaInstructionOpt) {
        LOG_ERROR("[AddressManager] Could not find AgentArray LEA instruction inside AvContext.");
        s_pointers.agentArray = 0;
        return;
    }

    uintptr_t leaInstructionAddress = *leaInstructionOpt;
    int32_t relativeOffset = *reinterpret_cast<int32_t*>(leaInstructionAddress + AddressingConstants::LEA_OFFSET_POSITION);
    uintptr_t addressOfNextInstruction = leaInstructionAddress + AddressingConstants::LEA_INSTRUCTION_SIZE;
    uintptr_t agentStructBase = addressOfNextInstruction + relativeOffset;
    s_pointers.agentArray = agentStructBase + AddressingConstants::AGENT_ARRAY_OFFSET;

    LOG_INFO("[AddressManager] -> SUCCESS: AgentArray resolved to: 0x%p", (void*)s_pointers.agentArray);
}

void AddressManager::ScanWorldViewContextPtr() {
    std::optional<uintptr_t> landmarkOpt = PatternScanner::FindPattern(
        std::string(WORLD_VIEW_CONTEXT_PATTERN),
        std::string(TARGET_PROCESS_NAME)
    );

    if (!landmarkOpt) {
        LOG_ERROR("[AddressManager] WorldViewContext pattern not found.");
        s_pointers.worldViewContextPtr = 0;
        return;
    }

    uintptr_t landmarkAddress = *landmarkOpt;
    uintptr_t movInstructionAddr = landmarkAddress - AddressingConstants::MOV_INSTRUCTION_SIZE;

    int32_t relativeOffset = *reinterpret_cast<int32_t*>(movInstructionAddr + AddressingConstants::MOV_OFFSET_POSITION);
    uintptr_t addressOfNextInstruction = movInstructionAddr + AddressingConstants::MOV_INSTRUCTION_SIZE;
    uintptr_t staticPointerAddress = addressOfNextInstruction + relativeOffset;

    s_pointers.worldViewContextPtr = *reinterpret_cast<uintptr_t*>(staticPointerAddress);

    if (s_pointers.worldViewContextPtr) {
        LOG_INFO("[AddressManager] -> SUCCESS: WorldViewContext resolved to: 0x%p", (void*)s_pointers.worldViewContextPtr);
    }
    else {
        LOG_ERROR("[AddressManager] ERROR: WvContext static address was null.");
    }
}

void AddressManager::ScanBgfxContextFunc()
{
    std::optional<uintptr_t> getContextOpt = PatternScanner::FindPattern(
        std::string(BGFX_CONTEXT_FUNC_PATTERN),
        std::string(TARGET_PROCESS_NAME)
    );

    if (!getContextOpt) {
        LOG_ERROR("[AddressManager] BGFX Context function pattern not found.");
        s_pointers.bgfxContextFunc = 0;
        return;
    }

    // The pattern is located inside the function. We must subtract the offset
    // to get the address of the function's first instruction.
    // Start of function: 00b41ef0
    // Start of pattern:  00b41f25
    // Offset = 0x35
    uintptr_t patternAddress = *getContextOpt;
    s_pointers.bgfxContextFunc = patternAddress - AddressingConstants::BGFX_PATTERN_OFFSET;

    LOG_INFO("[AddressManager] -> SUCCESS: BGFX Context function resolved to: 0x%p", (void*)s_pointers.bgfxContextFunc);
}

void AddressManager::ScanContextCollectionFunc()
{
    std::optional<uintptr_t> funcOpt = PatternScanner::FindPattern(
        std::string(CONTEXT_COLLECTION_FUNC_PATTERN),
        std::string(TARGET_PROCESS_NAME)
    );

    if (!funcOpt) {
        LOG_ERROR("[AddressManager] ContextCollection function pattern not found.");
        s_pointers.contextCollectionFunc = 0;
        return;
    }

    s_pointers.contextCollectionFunc = *funcOpt;
    LOG_INFO("[AddressManager] -> SUCCESS: ContextCollection function resolved to: 0x%p", (void*)s_pointers.contextCollectionFunc);
}

void AddressManager::ScanGameThreadUpdateFunc() {
    std::optional<uintptr_t> locatorOpt = PatternScanner::FindPattern(
        std::string(ALERT_CONTEXT_LOCATOR_PATTERN),
        std::string(TARGET_PROCESS_NAME)
    );

    if (!locatorOpt) {
        LOG_ERROR("[AddressManager] AlertContext locator pattern not found.");
        s_pointers.gameThreadUpdateFunc = 0;
        return;
    }

    uintptr_t callToGetterAddr = *locatorOpt - AddressingConstants::ALERT_CONTEXT_CALL_OFFSET;

    uintptr_t getterFuncAddr = ResolveRelativeAddress(callToGetterAddr, AddressingConstants::CALL_INSTRUCTION_SIZE);
    if (!getterFuncAddr) {
        s_pointers.gameThreadUpdateFunc = 0;
        return;
    }

    uintptr_t staticPtrAddr = ResolveRelativeAddress(getterFuncAddr, AddressingConstants::MOV_INSTRUCTION_SIZE);
    if (!staticPtrAddr) {
        s_pointers.gameThreadUpdateFunc = 0;
        return;
    }

    uintptr_t instancePtr = *reinterpret_cast<uintptr_t*>(staticPtrAddr);
    if (!instancePtr) {
        s_pointers.gameThreadUpdateFunc = 0;
        return;
    }

    uintptr_t* vtable = *reinterpret_cast<uintptr_t**>(instancePtr);
    if (!vtable) {
        s_pointers.gameThreadUpdateFunc = 0;
        return;
    }

    // Validate VTable pointer is within module bounds
    uintptr_t moduleBase = GetModuleBase();
    size_t moduleSize = GetModuleSize();
    uintptr_t vtableAddr = reinterpret_cast<uintptr_t>(vtable);

    if (moduleBase == 0 || moduleSize == 0) {
        LOG_ERROR("[AddressManager] Module information not available for VTable validation");
        s_pointers.gameThreadUpdateFunc = 0;
        return;
    }

    if (vtableAddr < moduleBase || vtableAddr >= (moduleBase + moduleSize)) {
        LOG_ERROR("[AddressManager] VTable pointer 0x%p outside module bounds [0x%p - 0x%p]",
                  (void*)vtableAddr, (void*)moduleBase, (void*)(moduleBase + moduleSize));
        s_pointers.gameThreadUpdateFunc = 0;
        return;
    }

    s_pointers.gameThreadUpdateFunc = vtable[AddressingConstants::GAME_THREAD_UPDATE_VTABLE_INDEX];

    // Also validate the final function pointer
    uintptr_t funcAddr = s_pointers.gameThreadUpdateFunc;
    if (funcAddr < moduleBase || funcAddr >= (moduleBase + moduleSize)) {
        LOG_ERROR("[AddressManager] GameThreadUpdate function 0x%p outside module bounds", (void*)funcAddr);
        s_pointers.gameThreadUpdateFunc = 0;
        return;
    }

    LOG_INFO("[AddressManager] -> SUCCESS: GameThreadUpdate function resolved to: 0x%p", (void*)s_pointers.gameThreadUpdateFunc);
}

void AddressManager::ScanModuleInformation() {
    HMODULE hModule = GetModuleHandleA("Gw2-64.exe");
    if (!hModule) {
        LOG_ERROR("[AddressManager] Failed to get handle for Gw2-64.exe");
        return;
    }

    MODULEINFO moduleInfo;
    if (!GetModuleInformation(GetCurrentProcess(), hModule, &moduleInfo, sizeof(moduleInfo))) {
        LOG_ERROR("[AddressManager] Failed to get module information for Gw2-64.exe");
        return;
    }

    s_pointers.moduleBase = reinterpret_cast<uintptr_t>(moduleInfo.lpBaseOfDll);
    s_pointers.moduleSize = moduleInfo.SizeOfImage;

    LOG_INFO("[AddressManager] Module Information - Base: 0x%p, Size: 0x%Ix", (void*)s_pointers.moduleBase, s_pointers.moduleSize);
}

void AddressManager::Scan() {
    LOG_INFO("[AddressManager] Scanning for memory addresses...");
    
    // Scan active pointers (currently used)
    ScanModuleInformation();
    ScanContextCollectionFunc();
    ScanGameThreadUpdateFunc();

    // Future feature scanners (currently inactive but kept for future use)
    // These are commented out to avoid unnecessary scanning overhead
    // but can be easily enabled when the features are implemented:
    //ScanAgentArray();           // For future ESP features
    //ScanWorldViewContextPtr();  // For future rendering features  
    //ScanBgfxContextFunc();      // For future rendering features
}

void AddressManager::Initialize() {
    Scan();
}

void* AddressManager::GetLocalPlayer() {
    if (!s_pointers.pContextCollection) return nullptr;
    
    return GetLocalPlayerImpl(s_pointers.pContextCollection);
}

// Implementation function to avoid object unwinding issues
void* AddressManager::GetLocalPlayerImpl(void* pContextCollection) {
    __try {
        ReClass::ContextCollection contextCollection(pContextCollection);
        ReClass::ChCliContext chContext = contextCollection.GetChCliContext();
        if (!chContext.data()) return nullptr;
        
        return chContext.GetLocalPlayer();
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        return nullptr;
    }
}

} // namespace kx
</file>

<file path="AddressManager.h">
#pragma once

#include <atomic>
#include <cstdint>

namespace kx {

/**
 * @brief Constants for memory scanning and address resolution
 * 
 * These constants define various offsets, sizes, and indices used in 
 * pattern scanning and RIP-relative address resolution.
 */
namespace AddressingConstants {
    // Instruction sizes for x64 architecture
    constexpr size_t RELATIVE_OFFSET_SIZE = 4;        // Size of relative offset in instructions
    constexpr size_t LEA_INSTRUCTION_SIZE = 7;        // Size of LEA instruction
    constexpr size_t CALL_INSTRUCTION_SIZE = 5;       // Size of CALL instruction
    constexpr size_t MOV_INSTRUCTION_SIZE = 7;        // Size of MOV instruction for RIP-relative addressing
    
    // Pattern search ranges
    constexpr size_t AGENT_ARRAY_SEARCH_RANGE = 0x300;  // Search range for LEA instruction in AvContext
    
    // Instruction offsets for parsing
    constexpr size_t LEA_OFFSET_POSITION = 3;         // Position of offset in LEA instruction
    constexpr size_t MOV_OFFSET_POSITION = 3;         // Position of offset in MOV instruction
    
    // Memory structure offsets
    constexpr size_t AGENT_ARRAY_OFFSET = 0x8;        // Offset from agent struct base to actual array
    
    // Pattern-specific offsets
    constexpr size_t BGFX_PATTERN_OFFSET = 0x35;      // Offset from pattern to function start
    constexpr size_t ALERT_CONTEXT_CALL_OFFSET = 0x19; // Offset from locator to call instruction
    
    // VTable indices
    constexpr size_t GAME_THREAD_UPDATE_VTABLE_INDEX = 0; // Index in VTable for GameThreadUpdate function
}

// A struct to hold all game-related pointers and addresses.
struct GamePointers {
    uintptr_t agentArray = 0;
    uintptr_t worldViewContextPtr = 0;
    uintptr_t bgfxContextFunc = 0;
    uintptr_t contextCollectionFunc = 0;
    uintptr_t gameThreadUpdateFunc = 0;
    std::atomic<void*> pContextCollection{nullptr};
    
    // Module information for VTable validation
    uintptr_t moduleBase = 0;
    size_t moduleSize = 0;
};

class AddressManager {
public:
    static void Initialize();

    // Public setter for the hook to store the captured pointer.
    static void SetContextCollectionPtr(void* ptr);

    // Inlined getters for direct and fast access.
    static uintptr_t GetAgentArray() { return s_pointers.agentArray; }
    static uintptr_t GetWorldViewContextPtr() { return s_pointers.worldViewContextPtr; }
    static uintptr_t GetBgfxContextFunc() { return s_pointers.bgfxContextFunc; }
    static uintptr_t GetContextCollectionFunc() { return s_pointers.contextCollectionFunc; }
    static uintptr_t GetGameThreadUpdateFunc() { return s_pointers.gameThreadUpdateFunc; }
    static void* GetContextCollectionPtr() { 
        return s_pointers.pContextCollection.load(std::memory_order_acquire); 
    }
    
    // Module information getters for VTable validation
    static uintptr_t GetModuleBase() { return s_pointers.moduleBase; }
    static size_t GetModuleSize() { return s_pointers.moduleSize; }

    // Local player detection
    static void* GetLocalPlayer();

private:
    static void* GetLocalPlayerImpl(void* pContextCollection); // Helper to avoid object unwinding issues
    static void Scan();
    static void ScanModuleInformation();
    static void ScanAgentArray();
    static void ScanWorldViewContextPtr();
    static void ScanBgfxContextFunc();
    static void ScanContextCollectionFunc();
    static void ScanGameThreadUpdateFunc();

    // Single static struct instance holding all pointers.
    static GamePointers s_pointers;
};

} // namespace kx
</file>

<file path="Camera.cpp">
#include "Camera.h"
#include "MumbleLinkManager.h"

#include <iostream>
#include <string>
#include <windows.h>

namespace kx {

    Camera::Camera() {
        m_viewMatrix = glm::mat4(1.0f);
        m_projectionMatrix = glm::mat4(1.0f);
        m_camPos = glm::vec3(0.0f);
        m_playerPosition = glm::vec3(0.0f);
    }

    Camera::~Camera() {
        // No longer responsible for MumbleLink cleanup
    }

    void Camera::Update(const MumbleLinkManager& mumbleManager, HWND hWnd) {
        const MumbleLinkData* mumbleData = mumbleManager.GetData();
        if (!mumbleData) {
            // If there's no data, don't update the matrices.
            // They will retain their last valid state.
            return;
        }

        // Get camera position from MumbleLink (already in Y-up)
        m_camPos = glm::vec3(
            mumbleData->fCameraPosition[0],
            mumbleData->fCameraPosition[1],
            mumbleData->fCameraPosition[2]
        );

        // Get player position from MumbleLink (already in Y-up)
        m_playerPosition = glm::vec3(
            mumbleData->fAvatarPosition[0],
            mumbleData->fAvatarPosition[1],
            mumbleData->fAvatarPosition[2]
        );

        // Get camera direction from MumbleLink
        glm::vec3 camFront = glm::vec3(
            mumbleData->fCameraFront[0],
            mumbleData->fCameraFront[1],
            mumbleData->fCameraFront[2]
        );

        // Get window dimensions for aspect ratio
        RECT rect;
        float screenWidth = 1920.0f;  // Default values in case GetClientRect fails
        float screenHeight = 1080.0f;
        if (hWnd && GetClientRect(hWnd, &rect)) {
            screenWidth = static_cast<float>(rect.right - rect.left);
            screenHeight = static_cast<float>(rect.bottom - rect.top);
        }

        // Get FOV from MumbleLinkManager (already parsed from identity data)
        float fov_radians = mumbleManager.GetFovOrDefault();

        // Calculate view matrix - manually implementing a left-handed lookAt
        glm::vec3 target = m_camPos + camFront;
        glm::vec3 worldUp = glm::vec3(0.0f, 1.0f, 0.0f); // Y is up in GW2's world space

        // Create view vectors
        glm::vec3 zaxis = glm::normalize(target - m_camPos); // Forward (positive Z in left-handed)
        glm::vec3 xaxis = glm::normalize(glm::cross(worldUp, zaxis)); // Right
        glm::vec3 yaxis = glm::cross(zaxis, xaxis); // Up

        // Build view matrix explicitly for left-handed system
        m_viewMatrix = glm::mat4(1.0f);
        m_viewMatrix[0][0] = xaxis.x;
        m_viewMatrix[0][1] = yaxis.x;
        m_viewMatrix[0][2] = zaxis.x;
        m_viewMatrix[1][0] = xaxis.y;
        m_viewMatrix[1][1] = yaxis.y;
        m_viewMatrix[1][2] = zaxis.y;
        m_viewMatrix[2][0] = xaxis.z;
        m_viewMatrix[2][1] = yaxis.z;
        m_viewMatrix[2][2] = zaxis.z;
        m_viewMatrix[3][0] = -glm::dot(xaxis, m_camPos);
        m_viewMatrix[3][1] = -glm::dot(yaxis, m_camPos);
        m_viewMatrix[3][2] = -glm::dot(zaxis, m_camPos);

        // Define perspective projection parameters
        float zNear = 0.1f;
        float zFar = 30000.0f;
        float aspect = screenWidth / screenHeight;

        // Build projection matrix explicitly for DirectX-style left-handed projection
        m_projectionMatrix = glm::mat4(0.0f);
        m_projectionMatrix[0][0] = 1.0f / (aspect * tanf(fov_radians / 2.0f));
        m_projectionMatrix[1][1] = 1.0f / tanf(fov_radians / 2.0f);
        m_projectionMatrix[2][2] = zFar / (zFar - zNear);
        m_projectionMatrix[2][3] = 1.0f;
        m_projectionMatrix[3][2] = -(zFar * zNear) / (zFar - zNear);
    }

} // namespace kx
</file>

<file path="Camera.h">
#pragma once

#include "glm.hpp"
#include "MumbleLink.h" // For the struct in the Update method parameter
#include "gtc/matrix_transform.hpp"

namespace kx {

    // Forward declaration
    class MumbleLinkManager;

    class Camera {
    public:
        Camera();
        ~Camera();
        void Update(const MumbleLinkManager& mumbleManager, HWND hWnd);

        const glm::mat4& GetViewMatrix() const { return m_viewMatrix; }
        const glm::mat4& GetProjectionMatrix() const { return m_projectionMatrix; }
        const glm::vec3& GetCameraPosition() const { return m_camPos; }
        const glm::vec3& GetPlayerPosition() const { return m_playerPosition; }

    private:
        glm::mat4 m_viewMatrix;
        glm::mat4 m_projectionMatrix;
        glm::vec3 m_camPos;
        glm::vec3 m_playerPosition;
    };

} // namespace kx
</file>

<file path="GameEnums.h">
#pragma once

#include <cstdint>

namespace kx {
namespace Game {

// Agent and Entity Types
enum class AgentType : int {
    Character = 0,
    Gadget = 10,
    GadgetAttackTarget = 11,
    Item = 15,
    Error = -1
};

enum class AgentCategory : int {
    Character = 0,
    Dynamic = 1,
    Keyframed = 2
};

// Character Information
enum class Profession : uint32_t {
    None = 0,
    Guardian = 1,
    Warrior = 2,
    Engineer = 3,
    Ranger = 4,
    Thief = 5,
    Elementalist = 6,
    Mesmer = 7,
    Necromancer = 8,
    Revenant = 9,
    End = 10
};

enum class Race : uint8_t {
    Asura = 0,
    Charr = 1,
    Human = 2,
    Norn = 3,
    Sylvari = 4,
    None = 5
};

enum class CharacterRank : int {
    Normal = 0,
    Ambient = 1,
    Veteran = 2,
    Elite = 3,
    Champion = 4,
    Legendary = 5,
    End = 6
};

// Bitmask flags for character ranks, read directly from memory
enum class CharacterRankFlags : uint32_t {
    None = 0,
    Champion = 1 << 1,    // Unverified, from previous knowledge
    Elite = 1 << 5,    // Unverified, from previous knowledge
    Legendary = 1 << 11,   // Unverified, from previous knowledge
    Ambient = 1 << 23,   // VERIFIED from memory dump
    Veteran = 1 << 29,   // VERIFIED from memory dump
};

enum class Attitude : uint32_t {
    Friendly = 0,
    Hostile = 1,
    Indifferent = 2,
    Neutral = 3
};

// Gadget Types - Most important for ESP filtering
enum class GadgetType : uint32_t {
    Destructible = 1,       // Training dummy, siege practice targets
    Point = 2,              // PvP control points, event spawns
    Generic = 3,            // Generic, often invisible, trigger
    Generic2 = 4,
    Crafting = 5,           // Crafting stations
    Door = 6,               // Interactive doors, gates
    BountyBoard = 11,       // Bounty boards
    Interact = 12,          // Chests, portals
    Rift = 13,              // Reality Rifts
    PlayerSpecific = 14,    // Player-specific objects
    AttackTarget = 16,      // World bosses, fort walls
    MapPortal = 17,         // Map border portals
    Waypoint = 18,          // Waypoints
    ResourceNode = 19,      // Gathering nodes, chests
    Prop = 20,              // Supply depots, anvils, jump pads
    PlayerCreated = 23,     // Turrets, siege, guild banners
    Vista = 24,             // Vistas
    BuildSite = 25,         // WvW siege build sites
    None = 26
};

enum class ResourceNodeType : int {
    Plant = 0,
    Tree = 1,
    Rock = 2,
    Quest = 3,
    None = 4
};

// Attack Target Combat States
enum class AttackTargetCombatState : int32_t {
    Idle = 2,      // Idle/Inactive state
    InCombat = 3   // Active combat state
};

// Item Information
enum class ItemRarity : int {
    None = -1,
    Junk = 0,
    Common = 1,
    Fine = 2,
    Masterwork = 3,
    Rare = 4,
    Exotic = 5,
    Ascended = 6,
    Legendary = 7,
    End = 8
};

// Equipment Slots - Useful for equipment tracking
enum class EquipmentSlot : int {
    None = -1,
    AquaticHelm = 0,
    Back = 1,
    Chest = 2,
    Boots = 3,
    Gloves = 4,
    Helm = 5,
    Pants = 6,
    Shoulders = 7,

    TownChest = 14,
    TownBoots = 15,
    TownGloves = 16,
    TownHelm = 17,
    TownPants = 18,

    Accessory1 = 19,
    Accessory2 = 20,
    Ring1 = 21,
    Ring2 = 22,
    Amulet = 23,

    AquaticWeapon1 = 24,
    AquaticWeapon2 = 25,
    Novelty = 26,
    TransformWeapon = 27,

    MainhandWeapon1 = 29,
    OffhandWeapon1 = 30,
    MainhandWeapon2 = 31,
    OffhandWeapon2 = 32,
    Toy = 33,
    ForagingTool = 34,
    LoggingTool = 35,
    MiningTool = 36,

    PvpAquaticHelm = 40,
    PvpBack = 41,
    PvpChest = 42,
    PvpBoots = 43,
    PvpGloves = 44,
    PvpHelm = 45,
    PvpPants = 46,
    PvpShoulders = 47,
    PvpAquaticWeapon1 = 48,
    PvpAquaticWeapon2 = 49,
    PvpMainhandWeapon1 = 50,
    PvpOffhandWeapon1 = 51,
    PvpMainhandWeapon2 = 52,
    PvpOffhandWeapon2 = 53,

    PvpAmulet = 58,
    FishingRod = 60,
    Relic = 67,
    Backpack1 = 68,
    End = 69
};

// Weapon Types
enum class WeaponType : int {
    None = -1,
    Sword = 0,
    Hammer = 1,
    Longbow = 2,
    Shortbow = 3,
    Axe = 4,
    Dagger = 5,
    Greatsword = 6,
    Mace = 7,
    Pistol = 8,
    Rifle = 10,
    Scepter = 11,
    Staff = 12,
    Focus = 13,
    Torch = 14,
    Warhorn = 15,
    Shield = 16,
    End = 23
};

// Breakbar States - Useful for NPC status
enum class BreakbarState : int {
    Ready = 0,
    Recover = 1,
    Immune = 2,
    None = 3
};

// Elite Specializations (using ArenaNet API IDs)
enum class EliteSpec : uint8_t {
    None = 0,
    Druid = 5,
    Daredevil = 7,
    Berserker = 18,
    Dragonhunter = 27,
    Reaper = 34,
    Chronomancer = 40,
    Scrapper = 43,
    Tempest = 48,
    Herald = 52,
    Soulbeast = 55,
    Weaver = 56,
    Holosmith = 57,
    Deadeye = 58,
    Mirage = 59,
    Scourge = 60,
    Spellbreaker = 61,
    Firebrand = 62,
    Renegade = 63,
    Harbinger = 64,
    Willbender = 65,
    Virtuoso = 66,
    Catalyst = 67,
    Bladesworn = 68,
    Vindicator = 69,
    Mechanist = 70,
    Specter = 71,
    Untamed = 72
};

// Mount Types
enum class MountType : uint8_t {
    None = 0,
    Jackal = 1,
    Griffon = 2,
    Springer = 3,
    Skimmer = 4,
    Raptor = 5,
    RollerBeetle = 6,
    Warclaw = 7,
    Skyscale = 8,
    Skiff = 9,
    SiegeTurtle = 10
};

// Combat Effects - Useful for buff/debuff tracking
enum class EffectType : uint32_t {
    None = 0,
    Protection = 717,
    Regeneration = 718,
    Swiftness = 719,
    Blind = 720,
    Crippled = 721,
    Chilled = 722,
    Poison = 723,
    Fury = 725,
    Vigor = 726,
    Immobilized = 727,
    Bleeding = 736,
    Burning = 737,
    Vulnerability = 738,
    Might = 740,
    Weakness = 742,
    Aegis = 743,
    Downed = 770,
    Fear = 791,
    Invulnerability = 848,
    Confusion = 861,
    Stun = 872,
    Retaliation = 873,
    Revealed = 890,
    Stability = 1122,
    Quickness = 1187,
    Stealth = 13017,
    Superspeed = 5974,
    Torment = 19426,
    Slow = 26766,
    Resistance = 26980,
    Alacrity = 30328
};

} // namespace Game
} // namespace kx
</file>

<file path="HavokEnums.h">
#pragma once

#include <cstdint>

/**
 * @file HavokEnums.h
 * @brief Enums for Havok Physics engine
 * 
 * This file contains enums for Havok Physics engine types used by Guild Wars 2.
 * These are low-level physics engine enums, separate from game-specific enums.
 */

namespace kx {
namespace Havok {

// Havok Physics Shape Types - hkcdShapeType enum
// Used to safely identify shape types before accessing shape-specific fields
enum class HkcdShapeType : uint8_t {
    SPHERE = 0,
    CYLINDER = 1,
    TRIANGLE = 2,
    BOX = 3,
    CAPSULE = 4,
    CONVEX_VERTICES = 5,
    TRI_SAMPLED_HEIGHT_FIELD_COLLECTION = 6,
    TRI_SAMPLED_HEIGHT_FIELD_BV_TREE = 7,
    LIST = 8,
    MOPP = 9,
    CONVEX_TRANSLATE = 10,
    CONVEX_TRANSFORM = 0x0B,
    SAMPLED_HEIGHT_FIELD = 0x0C,
    EXTENDED_MESH = 0x0D,
    TRANSFORM = 0x0E,
    COMPRESSED_MESH = 0x0F,
    STATIC_COMPOUND = 0x10,
    BV_COMPRESSED_MESH = 0x11,
    COLLECTION = 0x12,
    USER0 = 0x13,
    USER1 = 0x14,
    USER2 = 0x15,
    BV_TREE = 0x16,
    CONVEX = 0x17,
    CONVEX_PIECE = 0x18,
    MULTI_SPHERE = 0x19,
    CONVEX_LIST = 0x1A,
    TRIANGLE_COLLECTION = 0x1B,
    HEIGHT_FIELD = 0x1C,
    SPHERE_REP = 0x1D,
    BV = 0x1E,
    PLANE = 0x1F,
    PHANTOM_CALLBACK = 0x20,
    MULTI_RAY = 0x21,
    INVALID = 0x22,
    MAX_PPU_SHAPE_TYPE = 0x23,
    ALL_SHAPE_TYPES = 0xFF
};

} // namespace Havok
} // namespace kx
</file>

<file path="HavokOffsets.h">
#pragma once
#include <cstdint>

/**
 * @file HavokOffsets.h
 * @brief Memory offsets for Havok Physics engine structures
 * 
 * This file contains offsets for Havok Physics engine objects used by Guild Wars 2.
 * These are low-level physics engine structures, separate from game-specific structures.
 */

namespace HavokOffsets {
    
    // ============================================================================
    // HAVOK PHYSICS RIGID BODY
    // ============================================================================

    /**
     * @brief hkpRigidBody - Havok physics rigid body object
     * Contains physics simulation data and shape reference for dynamic objects (gadgets)
     */
    struct HkpRigidBody {
        static constexpr uintptr_t SHAPE = 0x0020;  // hkpShape* pointer to collision shape (e.g., hkpCylinderShape)
        static constexpr uintptr_t SHAPE_TYPE_WRAPPER = 0x4C;  // uint8_t hkcdShapeType - wrapper type (6=Terrain, 11=Transform)
        static constexpr uintptr_t WORLD_POINTER = 0x10;  // hkpWorld* pointer to the physics world this rigid body belongs to
    };

    /**
     * @brief Common offsets for all Havok shape types
     * 
     * NOTE: This is an offset struct only, NOT a ReClass wrapper class.
     * We read the primitive shape type byte directly from shape pointers using these offsets.
     * Unlike HkpBoxShape, HkpCylinderShape, etc., we don't need a ReClass wrapper class
     * for HkpShapeBase since we only access the primitive type field directly.
     * 
     * The primitive shape type is stored as a single byte at offset 0x10 in the shape object.
     */
    struct HkpShapeBase {
        static constexpr uintptr_t SHAPE_TYPE_PRIMITIVE = 0x10;  // uint8_t hkcdShapeType - primitive shape type (1=Cylinder, 3=Box, 4=Capsule, etc.)
    };

    // ============================================================================
    // HAVOK PHYSICS SHAPES
    // ============================================================================

    /**
     * @brief hkpBoxShape - Havok physics box shape object
     * Identified by SHAPE_TYPE_PRIMITIVE == 0x03.
     */
    struct HkpBoxShape {
        static constexpr uintptr_t COLLISION_RADIUS = 0x20;  // float: Base collision radius or padding
        static constexpr uintptr_t HALF_EXTENTS = 0x30;      // hkVector4: half-extents (width/2, depth/2, height/2, padding)
        static constexpr uintptr_t WIDTH_HALF = 0x30;        // float: X half-extent
        static constexpr uintptr_t DEPTH_HALF = 0x34;        // float: Y half-extent
        static constexpr uintptr_t HEIGHT_HALF = 0x38;       // float: Z half-extent
    };

    /**
     * @brief hkpCylinderShape - Havok physics cylinder collision shape
     * Identified by SHAPE_TYPE_PRIMITIVE == 0x01.
     */
    struct HkpCylinderShape {
        static constexpr uintptr_t RADIUS = 0x28;               // float: The cylinder's radius
        static constexpr uintptr_t HEIGHT_HALF_FLOAT = 0x2C;    // float: Half-height in meters. For primitive cylinders (ID 0x01)
    };

    /**
     * @brief hkpMoppBvTreeShape - Havok MOPP shape (BvTree)
     * Identified by SHAPE_TYPE_PRIMITIVE == 0x09.
     * This is an acceleration structure that wraps a child shape (e.g., a mesh).
     * To get its dimensions, you must get the child shape and find its AABB.
     */
    struct HkpMoppBvTreeShape {
        static constexpr uintptr_t CODE = 0x28;                    // hkpMoppCode*: Pointer to the compressed tree data
        static constexpr uintptr_t CHILD_SHAPE_POINTER = 0x58;    // hkpShape*: Pointer to the child shape (typically hkpExtendedMeshShape)
    };

    /**
     * @brief hkpExtendedMeshShape - A complex mesh shape, often the child of a MOPP
     * Identified by SHAPE_TYPE_PRIMITIVE == 0x0D.
     * These shapes cache their own Axis-Aligned Bounding Box (AABB) for performance.
     * The AABB is stored as an hkVector4 starting at 0xC0.
     */
    struct HkpExtendedMeshShape {
        static constexpr uintptr_t AABB_HALF_EXTENTS = 0xC0;  // hkVector4: Cached AABB half-extents (width/2, height/2, depth/2, padding)
        static constexpr uintptr_t AABB_WIDTH_HALF = 0xC0;    // float: X component (width/2)
        static constexpr uintptr_t AABB_DEPTH_HALF = 0xC4;   // float: Y component (depth/2 in Havok system)
        static constexpr uintptr_t AABB_HEIGHT_HALF = 0xC8;   // float: Z component (height/2 - confirmed this is height)
    };

    /**
     * @brief hkpSimpleShapePhantom - Havok physics phantom object
     * Contains physics-driven position data. Not a collision shape.
     */
    struct HkpSimpleShapePhantom {
        static constexpr uintptr_t PHYSICS_POSITION = 0x120;  // glm::vec3: Physics position
    };

    // ============================================================================
    // HAVOK PHYSICS WORLD AND BROADPHASE
    // ============================================================================

    /**
     * @brief hkpWorld - The main physics world object
     * Contains the broadphase border that manages world boundary phantoms
     */
    struct HkpWorld {
        static constexpr uintptr_t BROAD_PHASE_BORDER = 0x188;  // hkpBroadPhaseBorder* pointer to the object managing world boundary phantoms
    };

    /**
     * @brief hkpBroadPhaseBorder - Manages the 6 "wall" phantoms that define world boundaries
     * Contains an array of 6 hkpAabbPhantom pointers representing the world walls
     */
    struct HkpBroadPhaseBorder {
        static constexpr uintptr_t PHANTOM_ARRAY = 0x0;  // hkpPhantom*[6]: Array of 6 phantom pointers (world boundary walls)
    };

    /**
     * @brief hkpAabbPhantom - A phantom shape defined by a floating-point AABB
     * Used for world boundary walls and other non-colliding phantom objects
     */
    struct HkpAabbPhantom {
        static constexpr uintptr_t AABB_MIN = 0xF0;   // hkVector4: The minimum corner of the AABB
        static constexpr uintptr_t AABB_MAX = 0x100;  // hkVector4: The maximum corner of the AABB
    };

} // namespace HavokOffsets
</file>

<file path="MumbleLink.h">
#pragma once

#include <cstdint>
#include <string>
#include <windows.h>
#include "GameEnums.h"

namespace kx {

// ====== Forward Declarations ======
// Use consolidated enums from GameEnums.h
using Game::Profession;
using Game::Race;
using Game::EliteSpec;
using Game::MountType;

// ====== UI State Flags ======

// Mirroring Gw2Sharp's UiState enum
enum UiState : uint32_t {
    IsMapOpen = 1 << 0,
    IsCompassTopRight = 1 << 1,
    IsCompassRotationEnabled = 1 << 2,
    DoesGameHaveFocus = 1 << 3,
    IsCompetitiveMode = 1 << 4,
    DoesAnyInputHaveFocus = 1 << 5,
    IsInCombat = 1 << 6
};

// ====== Context Structures ======

/**
 * @brief Complete MumbleLink context structure (256 bytes)
 * Based on official GW2 MumbleLink specification
 */
#pragma pack(push, 1)
struct MumbleContext {
    uint8_t serverAddress[28];  // sockaddr_in or sockaddr_in6
    uint32_t mapId;
    uint32_t mapType;
    uint32_t shardId;
    uint32_t instance;
    uint32_t buildId;
    // Additional data beyond the 48 bytes Mumble uses for identification
    uint32_t uiState;          // Bitmask: See UiState enum
    uint16_t compassWidth;     // pixels
    uint16_t compassHeight;    // pixels
    float compassRotation;     // radians
    float playerX;             // continent coords
    float playerY;             // continent coords
    float mapCenterX;          // continent coords
    float mapCenterY;          // continent coords
    float mapScale;
    uint32_t processId;
    uint8_t mountIndex;
    uint8_t _padding[187];     // Pad to 256 bytes total
};
#pragma pack(pop)

// Legacy alias for backward compatibility
using Gw2Context = MumbleContext;

// ====== Identity Data ======

/**
 * @brief Parsed player identity information from MumbleLink
 * This data comes from the JSON-formatted identity field
 */
struct Identity {
    bool commander = false;           // Whether player is commanding in squad
    float fov = 0.0f;                // Field of view
    uint8_t uiScale = 0;             // UI scale setting
    Race race = Race::Human;         // Character race
    uint8_t specialization = 0;      // Elite specialization ID (raw value from API)
    Profession profession = Profession::None; // Character profession
    std::string name;                // Character name
};

// ====== Main MumbleLink Data Structure ======

#pragma pack(push, 1)
struct MumbleLinkData {
    UINT32 uiVersion;
    DWORD  uiTick;
    float  fAvatarPosition[3];
    float  fAvatarFront[3];
    float  fAvatarTop[3];
    wchar_t name[256];
    float  fCameraPosition[3];
    float  fCameraFront[3];
    float  fCameraTop[3];
    wchar_t identity[256];
    UINT32 context_len;
    MumbleContext context;
    wchar_t description[2048];
};
#pragma pack(pop)

} // namespace kx
</file>

<file path="MumbleLinkManager.cpp">
#include "MumbleLinkManager.h"

#include <nlohmann/json.hpp>
#include "../Utils/StringHelpers.h"

namespace kx {

MumbleLinkManager::MumbleLinkManager() {
    // Initialization is handled lazily in the first Update call
}

MumbleLinkManager::~MumbleLinkManager() {
    if (m_mumbleLink) UnmapViewOfFile(m_mumbleLink);
    if (m_mumbleLinkFile) CloseHandle(m_mumbleLinkFile);
}

bool MumbleLinkManager::Initialize() {
    m_mumbleLinkFile = CreateFileMappingW(
        INVALID_HANDLE_VALUE,
        NULL,
        PAGE_READWRITE,
        0,
        sizeof(MumbleLinkData),
        L"MumbleLink"
    );

    if (m_mumbleLinkFile == NULL) {
        m_status = MumbleStatus::Disconnected;
        return false;
    }

    m_mumbleLink = static_cast<MumbleLinkData*>(MapViewOfFile(
        m_mumbleLinkFile,
        FILE_MAP_READ,
        0,
        0,
        sizeof(MumbleLinkData)
    ));

    if (m_mumbleLink == NULL) {
        CloseHandle(m_mumbleLinkFile);
        m_mumbleLinkFile = nullptr;
        m_status = MumbleStatus::Disconnected;
        return false;
    }

    // On success, we just report that we have a mapped file.
    // We don't know if it's valid yet.
    m_status = MumbleStatus::Connecting;
    return true;
}

void MumbleLinkManager::Update() {
    if (!m_mumbleLink) {
        m_status = MumbleStatus::Disconnected;
        auto now = std::chrono::steady_clock::now();
        if (now - m_lastMumbleRetryTime >= MumbleRetryInterval) {
            m_lastMumbleRetryTime = now;
            Initialize();
        }
        return;
    }

    // The definitive check on every frame, as requested.
    bool isHeaderValid = (m_mumbleLink->uiVersion == 2 && std::wcscmp(m_mumbleLink->name, GW2_GAME_NAME) == 0);

    if (isHeaderValid) {
        m_status = MumbleStatus::Connected;
        if (m_mumbleLink->uiTick != m_lastTick) {
            m_lastTick = m_mumbleLink->uiTick;
            ParseIdentity();
        }
    } else {
        // Header is invalid.
        if (m_status == MumbleStatus::Connected) {
            // If we were connected, it means the game just closed. Disconnect fully.
            m_status = MumbleStatus::Disconnected;
            if (m_mumbleLink) {
                UnmapViewOfFile(m_mumbleLink);  // Properly unmap the view
                m_mumbleLink = nullptr;
            }
            if (m_mumbleLinkFile) {
                CloseHandle(m_mumbleLinkFile);
                m_mumbleLinkFile = nullptr;
            }
        } else {
            // Otherwise, we are connected to a file, but it has no valid game data.
            // This is the "Connecting" state. The GUI will handle what to do with it.
            m_status = MumbleStatus::Connecting;
        }
    }
}

// ====== Identity Parsing ======

void MumbleLinkManager::ParseIdentity() {
    if (!m_mumbleLink) {
        m_identity = Identity{}; // Reset to default
        return;
    }
    
    // Reset identity
    m_identity = Identity{};
    
    // Convert wchar_t identity to UTF-8
    std::string identityUtf8 = StringHelpers::WCharToUTF8String(m_mumbleLink->identity);
    
    // Check for conversion errors
    if (identityUtf8.empty() || identityUtf8 == "[STRING_TOO_LONG]" || identityUtf8 == "[CONVERSION_ERROR]") {
        return;
    }
    
    // Parse JSON
    auto json = nlohmann::json::parse(identityUtf8, nullptr, false);
    
    if (json.is_discarded()) {
        return; // Parsing failed
    }
    
    // Helper to safely extract values
    auto updateIfExists = [&json](auto& value, const char* key) {
        auto f = json.find(key);
        if (f != json.end() && !f->is_null()) {
            value = f->get<std::decay_t<decltype(value)>>();
        }
    };
    
    // Extract identity fields
    updateIfExists(m_identity.commander, "commander");
    updateIfExists(m_identity.fov, "fov");
    updateIfExists(m_identity.uiScale, "uisz");
    
    // Race - convert uint8_t to Race enum
    uint8_t raceValue = 0;
    updateIfExists(raceValue, "race");
    if (raceValue <= 4) {
        m_identity.race = static_cast<Race>(raceValue);
    }
    
    updateIfExists(m_identity.specialization, "spec");
    
    // Profession - convert uint8_t to Profession enum
    uint8_t profValue = 0;
    updateIfExists(profValue, "profession");
    if (profValue <= 9) {
        m_identity.profession = static_cast<Profession>(profValue);
    }
    
    updateIfExists(m_identity.name, "name");
}

// ====== Helper Methods ======

bool MumbleLinkManager::isInCombat() const {
    if (!m_mumbleLink) return false;
    return (m_mumbleLink->context.uiState & IsInCombat) != 0;
}

bool MumbleLinkManager::isInWvW() const {
    if (!m_mumbleLink) return false;
    
    uint32_t mt = m_mumbleLink->context.mapType;
    return mt == 18 || (mt >= 9 && mt <= 15 && mt != 13);
}

MountType MumbleLinkManager::currentMount() const {
    if (!m_mumbleLink) return MountType::None;
    
    uint8_t mountIdx = m_mumbleLink->context.mountIndex;
    if (mountIdx > 10) return MountType::None;
    
    return static_cast<MountType>(mountIdx);
}

bool MumbleLinkManager::isMounted() const {
    if (!m_mumbleLink) return false;
    return m_mumbleLink->context.mountIndex != 0;
}

uint32_t MumbleLinkManager::mapId() const {
    if (!m_mumbleLink) return 0;
    return m_mumbleLink->context.mapId;
}

Profession MumbleLinkManager::characterProfession() const {
    return m_identity.profession;
}

Race MumbleLinkManager::characterRace() const {
    return m_identity.race;
}

EliteSpec MumbleLinkManager::characterSpecialization() const {
    return ConvertAnetSpecIdToEliteSpec(m_identity.specialization);
}

const std::string& MumbleLinkManager::characterName() const {
    return m_identity.name;
}

uint32_t MumbleLinkManager::uiState() const {
    if (!m_mumbleLink) return 0;
    return m_mumbleLink->context.uiState;
}

float MumbleLinkManager::GetFov() const {
    return m_identity.fov;
}

float MumbleLinkManager::GetFovOrDefault(float defaultFov) const {
    return (m_identity.fov > 0.01f) ? m_identity.fov : defaultFov;
}

// ====== Elite Specialization Conversion ======

Game::EliteSpec MumbleLinkManager::ConvertAnetSpecIdToEliteSpec(uint8_t anetId) const {
    // EliteSpec enum now uses ArenaNet API IDs directly, so we can cast directly
    // Only validate that the ID is within the known range
    if (anetId == 0 || (anetId >= 5 && anetId <= 72)) {
        return static_cast<Game::EliteSpec>(anetId);
    }
    return Game::EliteSpec::None;
}

} // namespace kx
</file>

<file path="MumbleLinkManager.h">
#pragma once

#include <chrono>
#include <windows.h>

#include "MumbleLink.h"

namespace kx {

class MumbleLinkManager {
public:
    enum class MumbleStatus {
        Disconnected,
        Connecting,  // File is mapped, but header is invalid.
        Connected    // File is mapped, and header is valid.
    };

    MumbleLinkManager();
    ~MumbleLinkManager();

    void Update();
    const MumbleLinkData* GetData() const { return m_mumbleLink; }
    bool IsInitialized() const { return m_status == MumbleStatus::Connected; }
    MumbleStatus GetStatus() const { return m_status; }

    // ====== Helper Methods ======
    
    /**
     * @brief Check if player is currently in combat
     */
    bool isInCombat() const;
    
    /**
     * @brief Check if player is in World vs World
     */
    bool isInWvW() const;
    
    /**
     * @brief Get the currently active mount
     */
    MountType currentMount() const;
    
    /**
     * @brief Check if player is mounted on any mount
     */
    bool isMounted() const;
    
    /**
     * @brief Get current map ID
     */
    uint32_t mapId() const;
    
    /**
     * @brief Get character profession
     */
    Profession characterProfession() const;
    
    /**
     * @brief Get character race
     */
    Race characterRace() const;
    
    /**
     * @brief Get character elite specialization (converted from raw API ID)
     */
    EliteSpec characterSpecialization() const;
    
    /**
     * @brief Get character name
     */
    const std::string& characterName() const;
    
    /**
     * @brief Get current UI state flags
     */
    uint32_t uiState() const;
    
    /**
     * @brief Get field of view from parsed identity data
     * @return FOV in radians, or 0.0f if not available
     */
    float GetFov() const;
    
    /**
     * @brief Get field of view with fallback to default value
     * @param defaultFov Default FOV to use if not available (default: 1.0472f ~60 degrees)
     * @return FOV in radians
     */
    float GetFovOrDefault(float defaultFov = 1.0472f) const;

private:
    bool Initialize();
    void ParseIdentity();
    EliteSpec ConvertAnetSpecIdToEliteSpec(uint8_t anetId) const;

    HANDLE m_mumbleLinkFile = nullptr;
    MumbleLinkData* m_mumbleLink = nullptr;
    
    MumbleStatus m_status = MumbleStatus::Disconnected;
    
    std::chrono::steady_clock::time_point m_lastMumbleRetryTime;
    const std::chrono::milliseconds MumbleRetryInterval = std::chrono::seconds(5);
    uint32_t m_lastTick = 0;
    const wchar_t* GW2_GAME_NAME = L"Guild Wars 2";
    
    // Parsed identity data
    Identity m_identity;
};

} // namespace kx
</file>

<file path="offsets.h">
#pragma once
#include <cstdint>

/**
 * @file offsets.h
 * @brief Memory offsets for Guild Wars 2 game structures
 * 
 * Organized into nested structs that mirror the game's class hierarchy.
 */

namespace Offsets {
    
    // ============================================================================
    // COORDINATE AND TRANSFORM STRUCTURES
    // ============================================================================

    /**
     * @brief CoChar - Character coordinate system for visual positioning
     * VISUAL_POSITION is the primary position source for real-time rendering.
     */
    struct CoChar {
        static constexpr uintptr_t VISUAL_POSITION = 0x30;  // glm::vec3 position (primary)
        static constexpr uintptr_t SIMPLE_CLI_WRAPPER = 0x88;   // CoCharSimpleCliWrapper* - contains additional position data and physics info
        static constexpr uintptr_t PHYSICS_PHANTOM_PLAYER = 0x100; // HkpSimpleShapePhantom* direct physics phantom pointer (PLAYER ONLY - NPCs are nullptr)
    };

    /**
     * @brief CoCharSimpleCliWrapper intermediate object accessed via CoChar->0x88
     * Note: PHYSICS_PHANTOM_PLAYER is player-only (nullptr for NPCs). BOX_SHAPE works for all entities.
     * Havok physics offsets are in HavokOffsets.h
     */
    struct CoCharSimpleCliWrapper {
        static constexpr uintptr_t POSITION_ALT1 = 0xB8;    // glm::vec3 alternative position 1
        static constexpr uintptr_t POSITION_ALT2 = 0x118;   // glm::vec3 alternative position 2 (may lag)
        static constexpr uintptr_t PHYSICS_PHANTOM_PLAYER = 0x78;  // hkpSimpleShapePhantom* physics object (PLAYER ONLY) - see HavokOffsets.h
        static constexpr uintptr_t BOX_SHAPE = 0xE8;        // hkpBoxShape* physics box shape (works for players AND NPCs) - see HavokOffsets.h
    };

    /**
     * @brief CoKeyframed - Coordinate system for keyframed objects (gadgets)
     */
    struct CoKeyframed {
        static constexpr uintptr_t POSITION = 0x0030;  // glm::vec3 position
        static constexpr uintptr_t RIGID_BODY = 0x0060; // hkpRigidBody* physics rigid body (gadgets only) - see HavokOffsets.h
    };

    // ============================================================================
    // AGENT STRUCTURES
    // ============================================================================

    /**
     * @brief AgChar - Agent wrapper for characters
     */
    struct AgChar {
        static constexpr uintptr_t CO_CHAR = 0x50;  // CoChar* coordinate system
        static constexpr uintptr_t TYPE = 0x08;     // int32_t agent type identifier
        static constexpr uintptr_t ID = 0x0C;       // int32_t agent ID
        static constexpr uintptr_t GROUNDED_POSITION32 = 0x120;  // glm::vec3 last grounded/navmesh position (scaled by 32)
    };

    /**
     * @brief AgKeyframed - Agent wrapper for keyframed objects (gadgets)
     * 
     * TYPE values:
     * - 10: Regular gadget (AgentType::Gadget)
     * - 11: Attack target (AgentType::GadgetAttackTarget) - walls, destructible objects
     */
    struct AgKeyframed {
        static constexpr uintptr_t TYPE = 0x08;            // int32_t agent type identifier
        static constexpr uintptr_t ID = 0x0C;              // int32_t agent ID
        static constexpr uintptr_t GADGET_TYPE = 0x40;     // uint32_t gadget type
        static constexpr uintptr_t CO_KEYFRAMED = 0x0050;  // CoKeyframed* coordinate system
    };

    /**
     * @brief AgentInl - Internal agent structure for attack targets
     * 
     * Internal class: Gw2::Engine::Agent::AgentInl
     * Used in the attack target list (walls, destructible objects, etc.)
     * Entries point to AgKeyframed with TYPE=11 (GadgetAttackTarget)
     */
    struct AgentInl {
        static constexpr uintptr_t AG_KEYFRAMED = 0x18;    // AgKeyframed* agent wrapper
        static constexpr uintptr_t COMBAT_STATE = 0x0034;  // int32_t combat state flag (2=Idle, 3=In Combat) [CONFIRMED]
        
        // Unreliable offsets - commented out for reference
        // static constexpr uintptr_t POSITION = 0x0028;      // glm::vec3 position (X, Y, Z at 0x0028, 0x002C, 0x0030) [UNRELIABLE - not standard position, requires conversion]
        // static constexpr uintptr_t STATE_FLAG_1 = 0x00D4;  // int32_t state flag [UNRELIABLE]
        // static constexpr uintptr_t STATE_FLAG_2 = 0x021C;  // int32_t state flag [UNRELIABLE]
        // static constexpr uintptr_t HEALTH = 0x0220;        // ChCliHealth* health subsystem pointer [UNRELIABLE - doesn't work]
        // static constexpr uintptr_t IS_DEFEATED_PTR_1 = 0x02B0; // void* pointer [UNRELIABLE]
        // static constexpr uintptr_t IS_DEFEATED_PTR_2 = 0x02B8; // void* pointer [UNRELIABLE]
    };

    // ============================================================================
    // CHARACTER SUBSYSTEMS
    // ============================================================================

    /**
     * @brief ChCliHealth - Character health management
     */
    struct ChCliHealth {
        static constexpr uintptr_t CURRENT = 0x0C;  // float current health
        static constexpr uintptr_t MAX = 0x10;      // float maximum health
        static constexpr uintptr_t HEALTH_REGEN_RATE = 0x14; // float health regeneration rate (0 in combat, often 10% of max HP otherwise)
        static constexpr uintptr_t BARRIER = 0x28;  // float current barrier
    };

    /**
     * @brief ChCliSpecialEnergies - Character mount/special energy management
     */
    struct ChCliSpecialEnergies {
        static constexpr uintptr_t CURRENT = 0x0C;  // float current energy
        static constexpr uintptr_t MAX = 0x10;      // float maximum energy
    };

    /**
     * @brief ChCliEnergies - Character dodge/endurance management
     */
    struct ChCliEnergies {
        static constexpr uintptr_t CURRENT = 0x10;  // float current endurance
        static constexpr uintptr_t MAX = 0x14;      // float maximum endurance
        // Note: A second pool might exist at offsets 0x18/0x20
    };

    /**
     * @brief ChCliCoreStats - Character core statistics (race, level, profession)
     */
    struct ChCliCoreStats {
        static constexpr uintptr_t RACE = 0x33;          // uint8_t race ID
        static constexpr uintptr_t LEVEL = 0xAC;         // uint32_t actual level
        static constexpr uintptr_t PROFESSION = 0x12C;   // uint32_t profession ID
        static constexpr uintptr_t SCALED_LEVEL = 0x234; // uint32_t scaled/effective level
    };

    // ============================================================================
    // EQUIPMENT AND INVENTORY
    // ============================================================================

    /**
     * @brief Stat - Item stat combination structure
     */
    struct Stat {
        static constexpr uintptr_t ID = 0x28;  // uint32_t stat combination ID
    };

    /**
     * @brief ItemDef - Item definition with ID and rarity
     */
    struct ItemDef {
        static constexpr uintptr_t ID = 0x28;      // uint32_t item ID
        static constexpr uintptr_t RARITY = 0x60;  // uint32_t rarity level
        static constexpr uintptr_t TEXT_NAME_ID = 0x80;       // uint32_t text ID for the item name
    };

    /**
     * @brief EquipSlot - Equipment slot containing item and stat data
     */
    struct EquipSlot {
        static constexpr uintptr_t ITEM_DEF = 0x40;      // ItemDef* item definition
        static constexpr uintptr_t STAT_GEAR = 0xA0;     // Stat* for armor/trinkets
        static constexpr uintptr_t STAT_WEAPON = 0xA8;   // Stat* for weapons
        
        // Historical/Unverified offsets from old GearCheck - require verification
        // static constexpr uintptr_t RUNE = 0xC0;    // Rune* upgrade
        // static constexpr uintptr_t SIGIL1 = 0xC8;  // Sigil* first weapon sigil
        // static constexpr uintptr_t SIGIL2 = 0xD0;  // Sigil* second weapon sigil
    };

    /**
     * @brief Inventory - Character inventory container
     */
    struct Inventory {
        static constexpr uintptr_t EQUIPMENT_ARRAY = 0x160;  // EquipSlot** array of equipment slots
    };

    // ============================================================================
    // CHARACTER MAIN STRUCTURE
    // ============================================================================

    /**
     * @brief ChCliCharacter - Main character structure containing all subsystems
     */
    struct ChCliCharacter {
        static constexpr uintptr_t AGENT = 0x98;          // AgChar* character's agent
        static constexpr uintptr_t ATTITUDE = 0x00C0;     // uint32_t attitude flags
        static constexpr uintptr_t RANK_FLAGS = 0x0264;   // uint32_t rank flags (veteran, elite, etc.)
        static constexpr uintptr_t CORE_STATS = 0x0388;   // ChCliCoreStats* stats subsystem
        static constexpr uintptr_t ENERGIES = 0x03D0;     // ChCliEnergies* dodge/endurance subsystem
        static constexpr uintptr_t SPECIAL_ENERGIES = 0x03D8; // ChCliSpecialEnergies* mount/special energy subsystem
        static constexpr uintptr_t HEALTH = 0x03E8;       // ChCliHealth* health subsystem
        static constexpr uintptr_t INVENTORY = 0x3F0;     // Inventory* inventory subsystem
    };

    /**
     * @brief ChCliPlayer - Player wrapper containing character and name
     */
    struct ChCliPlayer {
        static constexpr uintptr_t CHARACTER_PTR = 0x18;  // ChCliCharacter* player's character
        static constexpr uintptr_t NAME_PTR = 0x68;       // wchar_t* player name string
    };

    // ============================================================================
    // GADGET STRUCTURES
    // ============================================================================

    /**
     * @brief GdCliGadget - Game gadget/object structure
     */
    struct GdCliGadget {
        static constexpr uintptr_t AG_KEYFRAMED = 0x0038;         // AgKeyframed* agent wrapper
        static constexpr uintptr_t TYPE = 0x0208;                 // uint32_t gadget type
        static constexpr uintptr_t HEALTH = 0x0220;               // ChCliHealth* health subsystem
        static constexpr uintptr_t RESOURCE_NODE_TYPE = 0x04EC;   // uint32_t resource node type
        static constexpr uintptr_t FLAGS = 0x04F0;                // uint32_t gadget flags
        
        // Gadget flag constants
        static constexpr uint32_t FLAG_GATHERABLE = 0x2;  // Indicates gatherable resource
    };

    // ============================================================================
    // CONTEXT MANAGEMENT STRUCTURES
    // ============================================================================

    /**
     * @brief ChCliContext - Character context managing all characters and players
     * 
     * Note: CAPACITY/COUNT are element counts (not bytes), represent zone limits not visible entities.
     *       CAPACITY >= COUNT always. Arrays are sparse - use CAPACITY for iteration, validate pointers.
     */
    struct ChCliContext {
        static constexpr uintptr_t CHARACTER_LIST = 0x60;          // ChCliCharacter** array
        static constexpr uintptr_t CHARACTER_LIST_CAPACITY = 0x68; // uint32_t capacity (element count)
        static constexpr uintptr_t CHARACTER_LIST_COUNT = 0x6C;    // uint32_t count (element count)
        static constexpr uintptr_t PLAYER_LIST = 0x80;             // ChCliPlayer** array
        static constexpr uintptr_t PLAYER_LIST_CAPACITY = 0x88;    // uint32_t capacity (element count)
        static constexpr uintptr_t PLAYER_LIST_COUNT = 0x8C;       // uint32_t count (element count)
        static constexpr uintptr_t LOCAL_PLAYER = 0x98;            // ChCliCharacter* local player
    };

    /**
     * @brief GdCliContext - Gadget context managing all gadgets/objects
     * 
     * Note: CAPACITY/COUNT are element counts (not bytes), represent zone limits not visible entities.
     *       CAPACITY >= COUNT always. Arrays are sparse - use CAPACITY for iteration, validate pointers.
     */
    struct GdCliContext {
        static constexpr uintptr_t GADGET_LIST = 0x0030;          // GdCliGadget** array
        static constexpr uintptr_t GADGET_LIST_CAPACITY = 0x0038; // uint32_t capacity (element count)
        static constexpr uintptr_t GADGET_LIST_COUNT = 0x003C;    // uint32_t count (element count)
        
        // Attack target list (walls, destructible objects, etc.)
        // Internal class: Gw2::Engine::Agent::AgentInl
        // Entries are AgentInl structures pointing to AgKeyframed with TYPE=11 (GadgetAttackTarget)
        static constexpr uintptr_t ATTACK_TARGET_LIST = 0x0010;          // AgentInl** array
        static constexpr uintptr_t ATTACK_TARGET_LIST_CAPACITY = 0x0018; // uint32_t capacity (element count)
        static constexpr uintptr_t ATTACK_TARGET_LIST_COUNT = 0x001C;    // uint32_t count (element count)
    };

    /**
     * @brief ContextCollection - Root collection containing all context managers
     */
    struct ContextCollection {
        static constexpr uintptr_t CH_CLI_CONTEXT = 0x98;   // ChCliContext* character context
        static constexpr uintptr_t GD_CLI_CONTEXT = 0x0138; // GdCliContext* gadget context
    };

} // namespace Offsets
</file>

<file path="ReClass/AgentStructs.h">
#pragma once

#include "../../Utils/DebugLogger.h"
#include "../../Utils/SafeForeignClass.h"
#include "../offsets.h"
#include "../HavokOffsets.h"
#include "../GameEnums.h"
#include <glm.hpp>

namespace kx {
    namespace ReClass {

        // Forward declarations
        class AgChar;
        class CoChar;
        class CoCharSimpleCliWrapper;
        class HkpSimpleShapePhantom;
        class HkpBoxShape;

        /**
         * @brief Havok physics box shape object - contains collision box dimensions
         */
        class HkpBoxShape : public SafeForeignClass {
        public:
            HkpBoxShape(void* ptr) : SafeForeignClass(ptr) {}

            float GetHeightHalf() const {
                if (!data()) {
                    return 0.0f;
                }
                return ReadMember<float>(HavokOffsets::HkpBoxShape::HEIGHT_HALF, 0.0f);
            }

            float GetWidthHalf() const {
                if (!data()) {
                    return 0.0f;
                }
                return ReadMember<float>(HavokOffsets::HkpBoxShape::WIDTH_HALF, 0.0f);
            }

            float GetDepthHalf() const {
                if (!data()) {
                    return 0.0f;
                }
                return ReadMember<float>(HavokOffsets::HkpBoxShape::DEPTH_HALF, 0.0f);
            }

            float GetCollisionRadius() const {
                if (!data()) {
                    return 0.0f;
                }
                return ReadMember<float>(HavokOffsets::HkpBoxShape::COLLISION_RADIUS, 0.0f);
            }

            glm::vec3 GetHalfExtents() const {
                if (!data()) {
                    return { 0.0f, 0.0f, 0.0f };
                }
                return ReadMember<glm::vec3>(HavokOffsets::HkpBoxShape::HALF_EXTENTS, { 0.0f, 0.0f, 0.0f });
            }

            // Get full dimensions (half-extents * 2)
            glm::vec3 GetFullDimensions() const {
                glm::vec3 halfExtents = GetHalfExtents();
                return halfExtents * 2.0f;
            }
        };

        /**
         * @brief Havok physics phantom object - contains physics-simulated position
         * TESTED: Physics position updates similarly to Primary - smooth and accurate
         */
        class HkpSimpleShapePhantom : public SafeForeignClass {
        public:
            HkpSimpleShapePhantom(void* ptr) : SafeForeignClass(ptr) {}

            glm::vec3 GetPhysicsPosition() const {
                // TESTED: Updates similarly to Primary position - smooth and accurate
                if (!data()) {
                    return { 0.0f, 0.0f, 0.0f };
                }
                return ReadMember<glm::vec3>(HavokOffsets::HkpSimpleShapePhantom::PHYSICS_POSITION, { 0.0f, 0.0f, 0.0f });
            }
        };

        /**
         * @brief CoCharSimpleCliWrapper object accessed via CoChar->0x88 containing alternative positions
         * 
         * TEST RESULTS:
         * - GetPositionAlt1(): Updates similarly to Primary - smooth and accurate
         * - GetPositionAlt2(): LAGS BEHIND visual position - not recommended for real-time rendering
         * - GetPhysicsPhantom()->GetPhysicsPosition(): Updates similarly to Primary - smooth and accurate
         */
        class CoCharSimpleCliWrapper : public SafeForeignClass {
        public:
            CoCharSimpleCliWrapper(void* ptr) : SafeForeignClass(ptr) {}

            glm::vec3 GetPositionAlt1() const {
                // TESTED: Updates similarly to Primary position - smooth and accurate
                if (!data()) {
                    return { 0.0f, 0.0f, 0.0f };
                }
                return ReadMember<glm::vec3>(Offsets::CoCharSimpleCliWrapper::POSITION_ALT1, { 0.0f, 0.0f, 0.0f });
            }

            glm::vec3 GetPositionAlt2() const {
                // WARNING: TESTED - This position LAGS BEHIND the visual position
                // Not recommended for real-time rendering - causes visual delay
                if (!data()) {
                    return { 0.0f, 0.0f, 0.0f };
                }
                return ReadMember<glm::vec3>(Offsets::CoCharSimpleCliWrapper::POSITION_ALT2, { 0.0f, 0.0f, 0.0f });
            }

            HkpSimpleShapePhantom GetPhysicsPhantom() const {
                return ReadPointer<HkpSimpleShapePhantom>(Offsets::CoCharSimpleCliWrapper::PHYSICS_PHANTOM_PLAYER);
            }

            HkpBoxShape GetBoxShape() const {
                return ReadPointer<HkpBoxShape>(Offsets::CoCharSimpleCliWrapper::BOX_SHAPE);
            }
        };

        /**
         * @brief Coordinate/Object wrapper for character positioning
         */
        class CoChar : public SafeForeignClass {
        public:
            CoChar(void* ptr) : SafeForeignClass(ptr) {}

            glm::vec3 GetVisualPosition() const {
                // TESTED: Primary position source - smooth and accurate for real-time rendering
                // Only log memory access for successful reads to reduce spam
                if (!data()) {
                    return { 0.0f, 0.0f, 0.0f };
                }
                
                glm::vec3 result = ReadMember<glm::vec3>(Offsets::CoChar::VISUAL_POSITION, { 0.0f, 0.0f, 0.0f });
                
                return result;
            }

            CoCharSimpleCliWrapper GetSimpleCliWrapper() const {
                return ReadPointer<CoCharSimpleCliWrapper>(Offsets::CoChar::SIMPLE_CLI_WRAPPER);
            }
        };

        /**
         * @brief Agent wrapper for character entities
         */
        class AgChar : public SafeForeignClass {
        public:
            AgChar(void* ptr) : SafeForeignClass(ptr) {}

            CoChar GetCoChar() const {
                LOG_MEMORY("AgChar", "GetCoChar", data(), Offsets::AgChar::CO_CHAR);
                
                CoChar result = ReadPointer<CoChar>(Offsets::AgChar::CO_CHAR);
                
                LOG_PTR("CoChar", result.data());
                return result;
            }

            Game::AgentType GetType() const {
                LOG_MEMORY("AgChar", "GetType", data(), Offsets::AgChar::TYPE);
                
                uint32_t type = ReadMember<uint32_t>(Offsets::AgChar::TYPE, 0);
                
                LOG_DEBUG("AgChar::GetType - Type: %u", type);
                return static_cast<Game::AgentType>(type);
            }

            int32_t GetId() const {
                LOG_MEMORY("AgChar", "GetId", data(), Offsets::AgChar::ID);
                
                int32_t id = ReadMember<int32_t>(Offsets::AgChar::ID, 0);
                
                LOG_DEBUG("AgChar::GetId - ID: %d", id);
                return id;
            }

            /**
             * @brief Get last grounded/navmesh position (32-bit scaled coordinates)
             * @return Last position where entity was on ground/navmesh
             * @note Raw values are scaled by 32 (x/32, y/32, z/-32)
             * @note This position only updates when entity is grounded - does NOT update during jumps/falls
             * @note Useful for navmesh validation but NOT for real-time position tracking
             */
            glm::vec3 GetGroundedPosition32() const {
                if (!data()) {
                    return { 0.0f, 0.0f, 0.0f };
                }
                
                // Read the 32-bit scaled grounded position (last known ground/navmesh contact)
                glm::vec3 rawPos = ReadMember<glm::vec3>(Offsets::AgChar::GROUNDED_POSITION32, { 0.0f, 0.0f, 0.0f });
                
                // Convert from scaled coordinates to world coordinates
                // x and y are divided by 32, z is divided by -32 (inverted)
                return glm::vec3(
                    rawPos.x / 32.0f,
                    rawPos.y / 32.0f,
                    rawPos.z / -32.0f
                );
            }
        };

    } // namespace ReClass
} // namespace kx
</file>

<file path="ReClass/CharacterStructs.h">
#pragma once

#include "../../Utils/DebugLogger.h"
#include "../../Utils/SafeForeignClass.h"
#include "../GameEnums.h"
#include "../offsets.h"
#include "AgentStructs.h"
#include "EquipmentStructs.h"

namespace kx {
    namespace ReClass {

        /**
         * @brief Character health management wrapper
         */
        class ChCliHealth : public SafeForeignClass {
        public:
            ChCliHealth(void* ptr) : SafeForeignClass(ptr) {}
            
            float GetCurrent() const { 
                LOG_MEMORY("ChCliHealth", "GetCurrent", data(), Offsets::ChCliHealth::CURRENT);
                
                float current = ReadMember<float>(Offsets::ChCliHealth::CURRENT, 0.0f);
                
                LOG_DEBUG("ChCliHealth::GetCurrent - Current: %.2f", current);
                return current;
            }
            
            float GetMax() const { 
                LOG_MEMORY("ChCliHealth", "GetMax", data(), Offsets::ChCliHealth::MAX);
                
                float max = ReadMember<float>(Offsets::ChCliHealth::MAX, 0.0f);
                
                LOG_DEBUG("ChCliHealth::GetMax - Max: %.2f", max);
                return max;
            }

            float GetHealthRegenRate() const { 
                LOG_MEMORY("ChCliHealth", "GetHealthRegenRate", data(), Offsets::ChCliHealth::HEALTH_REGEN_RATE);
                
                float regenRate = ReadMember<float>(Offsets::ChCliHealth::HEALTH_REGEN_RATE, 0.0f);
                
                LOG_DEBUG("ChCliHealth::GetHealthRegenRate - Regen Rate: %.2f", regenRate);
                return regenRate;
            }

            float GetBarrier() const {
                LOG_MEMORY("ChCliHealth", "GetBarrier", data(), Offsets::ChCliHealth::BARRIER);

                float barrier = ReadMember<float>(Offsets::ChCliHealth::BARRIER, 0.0f);

                LOG_DEBUG("ChCliHealth::GetBarrier - Barrier: %.2f", barrier);
                return barrier;
            }
        };

        /**
         * @brief Character mount/special energy management wrapper
         */
        class ChCliSpecialEnergies : public SafeForeignClass {
        public:
            ChCliSpecialEnergies(void* ptr) : SafeForeignClass(ptr) {}
            
            float GetCurrent() const { 
                LOG_MEMORY("ChCliSpecialEnergies", "GetCurrent", data(), Offsets::ChCliSpecialEnergies::CURRENT);
                
                float current = ReadMember<float>(Offsets::ChCliSpecialEnergies::CURRENT, 0.0f);
                
                LOG_DEBUG("ChCliSpecialEnergies::GetCurrent - Current: %.2f", current);
                return current;
            }
            
            float GetMax() const { 
                LOG_MEMORY("ChCliSpecialEnergies", "GetMax", data(), Offsets::ChCliSpecialEnergies::MAX);
                
                float max = ReadMember<float>(Offsets::ChCliSpecialEnergies::MAX, 0.0f);
                
                LOG_DEBUG("ChCliSpecialEnergies::GetMax - Max: %.2f", max);
                return max;
            }
        };

        /**
         * @brief Character dodge/endurance management wrapper
         */
        class ChCliEnergies : public SafeForeignClass {
        public:
            ChCliEnergies(void* ptr) : SafeForeignClass(ptr) {}
            
            float GetCurrent() const { 
                LOG_MEMORY("ChCliEnergies", "GetCurrent", data(), Offsets::ChCliEnergies::CURRENT);
                
                float current = ReadMember<float>(Offsets::ChCliEnergies::CURRENT, 0.0f);
                
                LOG_DEBUG("ChCliEnergies::GetCurrent - Current: %.2f", current);
                return current;
            }
            
            float GetMax() const { 
                LOG_MEMORY("ChCliEnergies", "GetMax", data(), Offsets::ChCliEnergies::MAX);
                
                float max = ReadMember<float>(Offsets::ChCliEnergies::MAX, 0.0f);
                
                LOG_DEBUG("ChCliEnergies::GetMax - Max: %.2f", max);
                return max;
            }
        };

        /**
         * @brief Character core statistics wrapper
         */
        class ChCliCoreStats : public SafeForeignClass {
        public:
            ChCliCoreStats(void* ptr) : SafeForeignClass(ptr) {}
            
            Game::Race GetRace() const { 
                LOG_MEMORY("ChCliCoreStats", "GetRace", data(), Offsets::ChCliCoreStats::RACE);
                
                if (!data()) {
                    LOG_ERROR("ChCliCoreStats::GetRace - ChCliCoreStats data is null");
                    return Game::Race::None;
                }
                
                uint8_t raceValue = 0;
                if (!kx::Debug::SafeRead<uint8_t>(data(), Offsets::ChCliCoreStats::RACE, raceValue)) {
                    LOG_ERROR("ChCliCoreStats::GetRace - Failed to read race at offset 0x33");
                    return Game::Race::None;
                }
                
                Game::Race race = static_cast<Game::Race>(raceValue);
                LOG_DEBUG("ChCliCoreStats::GetRace - Race: %u", static_cast<uint8_t>(race));
                return race;
            }
            
            uint32_t GetLevel() const { 
                LOG_MEMORY("ChCliCoreStats", "GetLevel", data(), Offsets::ChCliCoreStats::LEVEL);
                
                uint32_t level = ReadMember<uint32_t>(Offsets::ChCliCoreStats::LEVEL, 0);
                
                LOG_DEBUG("ChCliCoreStats::GetLevel - Level: %u", level);
                return level;
            }

            uint32_t GetScaledLevel() const {
                LOG_MEMORY("ChCliCoreStats", "GetScaledLevel", data(), Offsets::ChCliCoreStats::SCALED_LEVEL);

                uint32_t scaledLevel = ReadMember<uint32_t>(Offsets::ChCliCoreStats::SCALED_LEVEL, 0);

                LOG_DEBUG("ChCliCoreStats::GetScaledLevel - Level: %u", scaledLevel);
                return scaledLevel;
            }

            Game::Profession GetProfession() const { 
                LOG_MEMORY("ChCliCoreStats", "GetProfession", data(), Offsets::ChCliCoreStats::PROFESSION);
                
                uint32_t profValue = ReadMember<uint32_t>(Offsets::ChCliCoreStats::PROFESSION, 0);
                Game::Profession profession = static_cast<Game::Profession>(profValue);
                
                LOG_DEBUG("ChCliCoreStats::GetProfession - Profession: %u", static_cast<uint32_t>(profession));
                return profession;
            }
        };

        /**
         * @brief Main character wrapper with access to all character subsystems
         */
        class ChCliCharacter : public SafeForeignClass {
        public:
            ChCliCharacter(void* ptr) : SafeForeignClass(ptr) {}

            AgChar GetAgent() const {
                return ReadPointer<AgChar>(Offsets::ChCliCharacter::AGENT);
            }

            ChCliHealth GetHealth() const { 
                LOG_MEMORY("ChCliCharacter", "GetHealth", data(), Offsets::ChCliCharacter::HEALTH);
                
                ChCliHealth result = ReadPointer<ChCliHealth>(Offsets::ChCliCharacter::HEALTH);
                
                LOG_PTR("Health", result.data());
                return result;
            }

            ChCliEnergies GetEnergies() const { 
                LOG_MEMORY("ChCliCharacter", "GetEnergies", data(), Offsets::ChCliCharacter::ENERGIES);
                
                ChCliEnergies result = ReadPointer<ChCliEnergies>(Offsets::ChCliCharacter::ENERGIES);
                
                LOG_PTR("Energies", result.data());
                return result;
            }

            ChCliSpecialEnergies GetSpecialEnergies() const { 
                LOG_MEMORY("ChCliCharacter", "GetSpecialEnergies", data(), Offsets::ChCliCharacter::SPECIAL_ENERGIES);
                
                ChCliSpecialEnergies result = ReadPointer<ChCliSpecialEnergies>(Offsets::ChCliCharacter::SPECIAL_ENERGIES);
                
                LOG_PTR("SpecialEnergies", result.data());
                return result;
            }

            ChCliCoreStats GetCoreStats() const { 
                LOG_MEMORY("ChCliCharacter", "GetCoreStats", data(), Offsets::ChCliCharacter::CORE_STATS);
                
                ChCliCoreStats result = ReadPointer<ChCliCoreStats>(Offsets::ChCliCharacter::CORE_STATS);
                
                LOG_PTR("CoreStats", result.data());
                return result;
            }

            Game::Attitude GetAttitude() const {
                LOG_MEMORY("ChCliCharacter", "GetAttitude", data(), Offsets::ChCliCharacter::ATTITUDE);

                uint32_t attitudeValue = ReadMember<uint32_t>(Offsets::ChCliCharacter::ATTITUDE, 1);
                Game::Attitude attitude = static_cast<Game::Attitude>(attitudeValue);
                
                LOG_DEBUG("ChCliCharacter::GetAttitude - Attitude: %u", static_cast<uint32_t>(attitude));
                return attitude;
            }

            Game::CharacterRank GetRank() const {
                LOG_MEMORY("ChCliCharacter", "GetRank", data(), Offsets::ChCliCharacter::RANK_FLAGS);

                uint32_t flags = ReadMember<uint32_t>(Offsets::ChCliCharacter::RANK_FLAGS, 0);

                // Check from highest rank to lowest
                if ((flags & static_cast<uint32_t>(Game::CharacterRankFlags::Legendary)) != 0)
                    return Game::CharacterRank::Legendary;
                if ((flags & static_cast<uint32_t>(Game::CharacterRankFlags::Champion)) != 0)
                    return Game::CharacterRank::Champion;
                if ((flags & static_cast<uint32_t>(Game::CharacterRankFlags::Elite)) != 0)
                    return Game::CharacterRank::Elite;
                if ((flags & static_cast<uint32_t>(Game::CharacterRankFlags::Veteran)) != 0)
                    return Game::CharacterRank::Veteran;
                if ((flags & static_cast<uint32_t>(Game::CharacterRankFlags::Ambient)) != 0)
                    return Game::CharacterRank::Ambient;

                return Game::CharacterRank::Normal;
            }

            Inventory GetInventory() const {
                return ReadPointer<Inventory>(Offsets::ChCliCharacter::INVENTORY);
            }
        };

        /**
         * @brief Player wrapper that contains character data and player name
         */
        class ChCliPlayer : public SafeForeignClass {
        public:
            ChCliPlayer(void* ptr) : SafeForeignClass(ptr) {}
            
            ChCliCharacter GetCharacter() const { 
                if (!data()) {
                    return ChCliCharacter(nullptr);
                }
                
                void* characterPtr = nullptr;
                if (!kx::Debug::SafeRead<void*>(data(), Offsets::ChCliPlayer::CHARACTER_PTR, characterPtr)) {
                    return ChCliCharacter(nullptr);
                }
                
                return ChCliCharacter(characterPtr);
            }
            
            const wchar_t* GetName() const { 
                if (!data()) {
                    return nullptr;
                }
                
                wchar_t* namePtr = nullptr;
                if (!kx::Debug::SafeRead<wchar_t*>(data(), Offsets::ChCliPlayer::NAME_PTR, namePtr)) {
                    return nullptr;
                }
                
                return namePtr;
            }
        };

    } // namespace ReClass
} // namespace kx
</file>

<file path="ReClass/ContextStructs.h">
#pragma once

#include "../../Utils/DebugLogger.h"
#include "../../Utils/SafeForeignClass.h"
#include "../offsets.h"
#include "CharacterStructs.h"
#include "GadgetStructs.h"

namespace kx {
    namespace ReClass {

        /**
         * @brief Character context manager - handles character and player lists
         */
        class ChCliContext : public SafeForeignClass {
        public:
            ChCliContext(void* ptr) : SafeForeignClass(ptr) {}

            ChCliCharacter** GetCharacterList() const {
                LOG_MEMORY("ChCliContext", "GetCharacterList", data(), Offsets::ChCliContext::CHARACTER_LIST);
                
                ChCliCharacter** characterList = ReadArrayPointer<ChCliCharacter*>(Offsets::ChCliContext::CHARACTER_LIST);
                
                LOG_PTR("CharacterList", characterList);
                return characterList;
            }

            uint32_t GetCharacterListCapacity() const {
                LOG_MEMORY("ChCliContext", "GetCharacterListCapacity", data(), Offsets::ChCliContext::CHARACTER_LIST_CAPACITY);
                
                uint32_t capacity = ReadMember<uint32_t>(Offsets::ChCliContext::CHARACTER_LIST_CAPACITY, 0);
                
                LOG_DEBUG("ChCliContext::GetCharacterListCapacity - Capacity: %u", capacity);
                return capacity;
            }

            uint32_t GetCharacterListCount() const {
                LOG_MEMORY("ChCliContext", "GetCharacterListCount", data(), Offsets::ChCliContext::CHARACTER_LIST_COUNT);
                
                uint32_t count = ReadMember<uint32_t>(Offsets::ChCliContext::CHARACTER_LIST_COUNT, 0);
                
                LOG_DEBUG("ChCliContext::GetCharacterListCount - Count: %u", count);
                return count;
            }

            ChCliPlayer** GetPlayerList() const {
                LOG_MEMORY("ChCliContext", "GetPlayerList", data(), Offsets::ChCliContext::PLAYER_LIST);
                
                ChCliPlayer** playerList = ReadArrayPointer<ChCliPlayer*>(Offsets::ChCliContext::PLAYER_LIST);
                
                LOG_PTR("PlayerList", playerList);
                return playerList;
            }

            uint32_t GetPlayerListCapacity() const {
                LOG_MEMORY("ChCliContext", "GetPlayerListCapacity", data(), Offsets::ChCliContext::PLAYER_LIST_CAPACITY);
                
                uint32_t capacity = ReadMember<uint32_t>(Offsets::ChCliContext::PLAYER_LIST_CAPACITY, 0);
                
                LOG_DEBUG("ChCliContext::GetPlayerListCapacity - Capacity: %u", capacity);
                return capacity;
            }

            uint32_t GetPlayerListCount() const {
                LOG_MEMORY("ChCliContext", "GetPlayerListCount", data(), Offsets::ChCliContext::PLAYER_LIST_COUNT);
                
                uint32_t count = ReadMember<uint32_t>(Offsets::ChCliContext::PLAYER_LIST_COUNT, 0);
                
                LOG_DEBUG("ChCliContext::GetPlayerListCount - Count: %u", count);
                return count;
            }

            ChCliCharacter* GetLocalPlayer() const {
                LOG_MEMORY("ChCliContext", "GetLocalPlayer", data(), Offsets::ChCliContext::LOCAL_PLAYER);
                
                ChCliCharacter* result = ReadMember<ChCliCharacter*>(Offsets::ChCliContext::LOCAL_PLAYER, nullptr);
                
                LOG_PTR("LocalPlayer", result);
                return result;
            }
        };

        /**
         * @brief Gadget context manager - handles gadget lists
         */
        class GdCliContext : public SafeForeignClass {
        public:
            GdCliContext(void* ptr) : SafeForeignClass(ptr) {}

            GdCliGadget** GetGadgetList() const {
                LOG_MEMORY("GdCliContext", "GetGadgetList", data(), Offsets::GdCliContext::GADGET_LIST);
                
                GdCliGadget** gadgetList = ReadArrayPointer<GdCliGadget*>(Offsets::GdCliContext::GADGET_LIST);
                
                LOG_PTR("GadgetList", gadgetList);
                return gadgetList;
            }

            uint32_t GetGadgetListCapacity() const {
                LOG_MEMORY("GdCliContext", "GetGadgetListCapacity", data(), Offsets::GdCliContext::GADGET_LIST_CAPACITY);
                
                uint32_t capacity = ReadMember<uint32_t>(Offsets::GdCliContext::GADGET_LIST_CAPACITY, 0);
                
                LOG_DEBUG("GdCliContext::GetGadgetListCapacity - Capacity: %u", capacity);
                return capacity;
            }

            uint32_t GetGadgetListCount() const {
                LOG_MEMORY("GdCliContext", "GetGadgetListCount", data(), Offsets::GdCliContext::GADGET_LIST_COUNT);
                
                uint32_t count = ReadMember<uint32_t>(Offsets::GdCliContext::GADGET_LIST_COUNT, 0);
                
                LOG_DEBUG("GdCliContext::GetGadgetListCount - Count: %u", count);
                return count;
            }

            AgentInl** GetAttackTargetList() const {
                LOG_MEMORY("GdCliContext", "GetAttackTargetList", data(), Offsets::GdCliContext::ATTACK_TARGET_LIST);
                
                AgentInl** attackTargetList = ReadArrayPointer<AgentInl*>(Offsets::GdCliContext::ATTACK_TARGET_LIST);
                
                LOG_PTR("AttackTargetList", attackTargetList);
                return attackTargetList;
            }

            uint32_t GetAttackTargetListCapacity() const {
                LOG_MEMORY("GdCliContext", "GetAttackTargetListCapacity", data(), Offsets::GdCliContext::ATTACK_TARGET_LIST_CAPACITY);
                
                uint32_t capacity = ReadMember<uint32_t>(Offsets::GdCliContext::ATTACK_TARGET_LIST_CAPACITY, 0);
                
                LOG_DEBUG("GdCliContext::GetAttackTargetListCapacity - Capacity: %u", capacity);
                return capacity;
            }

            uint32_t GetAttackTargetListCount() const {
                LOG_MEMORY("GdCliContext", "GetAttackTargetListCount", data(), Offsets::GdCliContext::ATTACK_TARGET_LIST_COUNT);
                
                uint32_t count = ReadMember<uint32_t>(Offsets::GdCliContext::ATTACK_TARGET_LIST_COUNT, 0);
                
                LOG_DEBUG("GdCliContext::GetAttackTargetListCount - Count: %u", count);
                return count;
            }
        };

        /**
         * @brief Root context collection - entry point for all game context access
         */
        class ContextCollection : public SafeForeignClass {
        public:
            ContextCollection(void* ptr) : SafeForeignClass(ptr) {
                // Debug: Log the ContextCollection base address using proper logging system
                if (ptr) {
                    LOG_DEBUG("ContextCollection base = 0x" + std::to_string(reinterpret_cast<uintptr_t>(ptr)));
                }
            }

            ChCliContext GetChCliContext() const {
                LOG_MEMORY("ContextCollection", "GetChCliContext", data(), Offsets::ContextCollection::CH_CLI_CONTEXT);
                
                ChCliContext result = ReadPointer<ChCliContext>(Offsets::ContextCollection::CH_CLI_CONTEXT);
                
                LOG_PTR("ChCliContext", result.data());
                return result;
            }

            GdCliContext GetGdCliContext() const {
                LOG_MEMORY("ContextCollection", "GetGdCliContext", data(), Offsets::ContextCollection::GD_CLI_CONTEXT);
                
                GdCliContext result = ReadPointer<GdCliContext>(Offsets::ContextCollection::GD_CLI_CONTEXT);
                
                LOG_PTR("GdCliContext", result.data());
                return result;
            }
        };

    } // namespace ReClass
} // namespace kx
</file>

<file path="ReClass/EquipmentStructs.h">
#pragma once

#include "../../Utils/SafeForeignClass.h"
#include "../offsets.h"
#include "ItemStructs.h"
#include "StatStructs.h"

namespace kx {
    namespace ReClass {

        // The total number of equipment slots in the game's data structure.
        constexpr int NUM_EQUIPMENT_SLOTS = 69;

        /**
         * @brief Wrapper for a single equipment slot.
         * Contains pointers to the item definition, stats, upgrades, etc.
         */
        class EquipSlot : public SafeForeignClass {
        public:
            EquipSlot(void* ptr) : SafeForeignClass(ptr) {}

            ItemDef GetItemDefinition() const {
                return ReadPointer<ItemDef>(Offsets::EquipSlot::ITEM_DEF);
            }

            Stat GetStatGear() const {
                return ReadPointer<Stat>(Offsets::EquipSlot::STAT_GEAR);
            }

            Stat GetStatWeapon() const {
                return ReadPointer<Stat>(Offsets::EquipSlot::STAT_WEAPON);
            }
        };

        /**
         * @brief Wrapper for the character's inventory.
         * Contains the array of equipped items.
         */
        class Inventory : public SafeForeignClass {
        public:
            Inventory(void* ptr) : SafeForeignClass(ptr) {}

            EquipSlot GetEquipSlot(int slotIndex) const {
                if (!data() || slotIndex < 0 || slotIndex >= NUM_EQUIPMENT_SLOTS) {
                    return EquipSlot(nullptr);
                }

                // Calculate the base address of the embedded equipment array
                uintptr_t arrayBaseAddress = reinterpret_cast<uintptr_t>(data()) + Offsets::Inventory::EQUIPMENT_ARRAY;

                // Now, safely read the pointer for the specific slot FROM the array
                void* slotPtr = nullptr;
                if (!kx::Debug::SafeRead<void*>(reinterpret_cast<void*>(arrayBaseAddress), slotIndex * sizeof(void*), slotPtr)) {
                    return EquipSlot(nullptr);
                }

                return EquipSlot(slotPtr);
            }
        };

    } // namespace ReClass
} // namespace kx
</file>

<file path="ReClass/GadgetStructs.h">
#pragma once

#include "../../Utils/DebugLogger.h"
#include "../../Utils/SafeForeignClass.h"
#include "../GameEnums.h"
#include "../offsets.h"
#include "CharacterStructs.h"
#include "AgentStructs.h"
#include "HavokStructs.h"
#include <glm.hpp>

namespace kx {
    namespace ReClass {

        // Forward declarations
        class CoKeyFramed;
        class AgKeyFramed;
        class GdCliGadget;
        class AgentInl;

        /**
         * @brief Coordinate/Object wrapper for keyframed entities (gadgets)
         */
        class CoKeyFramed : public SafeForeignClass {
        public:
            CoKeyFramed(void* ptr) : SafeForeignClass(ptr) {}

            glm::vec3 GetPosition() const {
                LOG_MEMORY("CoKeyFramed", "GetPosition", data(), Offsets::CoKeyframed::POSITION);
                
                glm::vec3 position = ReadMember<glm::vec3>(Offsets::CoKeyframed::POSITION, glm::vec3{0.0f, 0.0f, 0.0f});
                
                LOG_DEBUG("CoKeyFramed::GetPosition - Position: (%.2f, %.2f, %.2f)", position.x, position.y, position.z);
                return position;
            }

            HkpRigidBody GetRigidBody() const {
                return ReadPointer<HkpRigidBody>(Offsets::CoKeyframed::RIGID_BODY);
            }
        };

        /**
         * @brief Agent wrapper for keyframed entities
         */
        class AgKeyFramed : public SafeForeignClass {
        public:
            AgKeyFramed(void* ptr) : SafeForeignClass(ptr) {}

            CoKeyFramed GetCoKeyFramed() const {
                LOG_MEMORY("AgKeyFramed", "GetCoKeyFramed", data(), Offsets::AgKeyframed::CO_KEYFRAMED);
                
                CoKeyFramed result = ReadPointer<CoKeyFramed>(Offsets::AgKeyframed::CO_KEYFRAMED);
                
                LOG_PTR("CoKeyFramed", result.data());
                return result;
            }

            Game::AgentType GetType() const {
                LOG_MEMORY("AgKeyFramed", "GetType", data(), Offsets::AgKeyframed::TYPE);
                
                uint32_t type = ReadMember<uint32_t>(Offsets::AgKeyframed::TYPE, 0);
                
                LOG_DEBUG("AgKeyFramed::GetType - Type: %u", type);
                return static_cast<Game::AgentType>(type);
            }

            int32_t GetId() const {
                LOG_MEMORY("AgKeyFramed", "GetId", data(), Offsets::AgKeyframed::ID);
                
                int32_t id = ReadMember<int32_t>(Offsets::AgKeyframed::ID, 0);
                
                LOG_DEBUG("AgKeyFramed::GetId - ID: %d", id);
                return id;
            }
        };

        /**
         * @brief Client gadget wrapper
         */
        class GdCliGadget : public SafeForeignClass {
        public:
            GdCliGadget(void* ptr) : SafeForeignClass(ptr) {}

            Game::GadgetType GetGadgetType() const {
                LOG_MEMORY("GdCliGadget", "GetGadgetType", data(), Offsets::GdCliGadget::TYPE);
                
                uint32_t typeValue = ReadMember<uint32_t>(Offsets::GdCliGadget::TYPE, 0);
                Game::GadgetType gadgetType = static_cast<Game::GadgetType>(typeValue);
                
                LOG_DEBUG("GdCliGadget::GetGadgetType - Type: %u", static_cast<uint32_t>(gadgetType));
                return gadgetType;
            }

            ChCliHealth GetHealth() const {
                LOG_MEMORY("GdCliGadget", "GetHealth", data(), Offsets::GdCliGadget::HEALTH);

                ChCliHealth result = ReadPointer<ChCliHealth>(Offsets::GdCliGadget::HEALTH);

                LOG_PTR("Health", result.data());
                return result;
            }

            Game::ResourceNodeType GetResourceNodeType() const {
                LOG_MEMORY("GdCliGadget", "GetResourceNodeType", data(), Offsets::GdCliGadget::RESOURCE_NODE_TYPE);

                return ReadMember<Game::ResourceNodeType>(Offsets::GdCliGadget::RESOURCE_NODE_TYPE, Game::ResourceNodeType::None);
            }

            bool IsGatherable() const {
                LOG_MEMORY("GdCliGadget", "IsGatherable", data(), Offsets::GdCliGadget::FLAGS);
                
                uint32_t flags = ReadMember<uint32_t>(Offsets::GdCliGadget::FLAGS, 0);
                bool gatherable = (flags & Offsets::GdCliGadget::FLAG_GATHERABLE) != 0;
                
                LOG_DEBUG("GdCliGadget::IsGatherable - Flags: 0x%X, Gatherable: %s", flags, gatherable ? "true" : "false");
                return gatherable;
            }

            AgKeyFramed GetAgKeyFramed() const {
                LOG_MEMORY("GdCliGadget", "GetAgKeyFramed", data(), Offsets::GdCliGadget::AG_KEYFRAMED);
                
                AgKeyFramed result = ReadPointer<AgKeyFramed>(Offsets::GdCliGadget::AG_KEYFRAMED);
                
                LOG_PTR("AgKeyFramed", result.data());
                return result;
            }
        };

        /**
         * @brief AgentInl - Internal agent structure wrapper for attack targets
         * 
         * Internal class: Gw2::Engine::Agent::AgentInl
         * Used in the attack target list (walls, destructible objects, etc.)
         * Contains position, health, combat state, and defeat status information.
         */
        class AgentInl : public SafeForeignClass {
        public:
            AgentInl(void* ptr) : SafeForeignClass(ptr) {}

            AgKeyFramed GetAgKeyFramed() const {
                LOG_MEMORY("AgentInl", "GetAgKeyFramed", data(), Offsets::AgentInl::AG_KEYFRAMED);
                
                AgKeyFramed result = ReadPointer<AgKeyFramed>(Offsets::AgentInl::AG_KEYFRAMED);
                
                LOG_PTR("AgKeyFramed", result.data());
                return result;
            }

            Game::AttackTargetCombatState GetCombatState() const {
                LOG_MEMORY("AgentInl", "GetCombatState", data(), Offsets::AgentInl::COMBAT_STATE);
                
                int32_t state = ReadMember<int32_t>(Offsets::AgentInl::COMBAT_STATE, 0);
                
                LOG_DEBUG("AgentInl::GetCombatState - State: %d", state);
                return static_cast<Game::AttackTargetCombatState>(state);
            }
        };

    } // namespace ReClass
} // namespace kx
</file>

<file path="ReClass/HavokStructs.h">
#pragma once

#include "../../Utils/DebugLogger.h"
#include "../../Utils/SafeForeignClass.h"
#include "../HavokEnums.h"
#include "../HavokOffsets.h"
#include <glm.hpp>
#include <cmath>

namespace kx {
    namespace ReClass {

        // Forward declarations
        class HkpBoxShape;
        class HkpMoppBvTreeShape;
        class HkpExtendedMeshShape;

        /**
         * @brief Havok physics cylinder collision shape - contains gadget dimensions
         */
        class HkpCylinderShape : public SafeForeignClass {
        public:
            HkpCylinderShape(void* ptr) : SafeForeignClass(ptr) {}

            // Deprecated: Use HkpRigidBody::TryGetDimensions() for type-safe dimension extraction
            [[deprecated("Use HkpRigidBody::TryGetDimensions() for type-safe dimension extraction")]]
            float GetHeightHalfMeters() const {
                if (!data()) {
                    return 0.0f;
                }
                return ReadMember<float>(HavokOffsets::HkpCylinderShape::HEIGHT_HALF_FLOAT, 0.0f);
            }
        };

        /**
         * @brief ReClass wrapper for an hkpMoppBvTreeShape
         * MOPP shapes are acceleration structures that wrap a child shape (typically hkpExtendedMeshShape)
         */
        class HkpMoppBvTreeShape : public SafeForeignClass {
        public:
            HkpMoppBvTreeShape(void* ptr) : SafeForeignClass(ptr) {}

            /**
             * @brief Gets a pointer to the child shape that this MOPP tree wraps
             * @return A void pointer to the child shape (e.g., an hkpExtendedMeshShape), or nullptr if invalid
             */
            void* GetChildShape() const {
                if (!data()) {
                    return nullptr;
                }
                return ReadMember<void*>(HavokOffsets::HkpMoppBvTreeShape::CHILD_SHAPE_POINTER, nullptr);
            }
        };

        /**
         * @brief ReClass wrapper for an hkpExtendedMeshShape
         * These complex mesh shapes cache their own AABB for performance
         */
        class HkpExtendedMeshShape : public SafeForeignClass {
        public:
            HkpExtendedMeshShape(void* ptr) : SafeForeignClass(ptr) {}

            /**
             * @brief Reads the cached AABB half-extents from the shape
             * @return A vec3 containing the half-dimensions in game coordinates (width/2, depth/2, height/2), or glm::vec3(0.0f) if invalid
             * 
             * Reads individual components from the AABB structure:
             * - 0xC0: Width (X component)
             * - 0xC4: Depth (Y component in Havok, maps to Y/depth in game)
             * - 0xC8: Height (Z component in Havok, confirmed by user as height)
             * 
             * Returns in game coordinate system: (width, depth, height) = (X, Y, Z)
             */
            glm::vec3 GetAabbHalfExtents() const {
                if (!data()) {
                    return glm::vec3(0.0f);
                }
                
                // Read individual components from AABB structure
                float widthHalf = ReadMember<float>(HavokOffsets::HkpExtendedMeshShape::AABB_WIDTH_HALF, 0.0f);
                float depthHalf = ReadMember<float>(HavokOffsets::HkpExtendedMeshShape::AABB_DEPTH_HALF, 0.0f);
                float heightHalf = ReadMember<float>(HavokOffsets::HkpExtendedMeshShape::AABB_HEIGHT_HALF, 0.0f);
                
                // Return in game coordinate system: (width, depth, height) = (X, Y, Z)
                return glm::vec3(widthHalf, depthHalf, heightHalf);
            }
        };

        /**
         * @brief Havok physics rigid body - contains physics shape reference
         * 
         * Type-safe shape dimension extraction using primitive shape type byte at shape+0x10.
         * This prevents unsafe casts and reading incorrect fields from wrong shape types.
         */
        class HkpRigidBody : public SafeForeignClass {
        public:
            HkpRigidBody(void* ptr) : SafeForeignClass(ptr) {}

            /**
             * @brief Get the wrapper shape type from the rigid body (for future filtering/early-out)
             * @return Wrapper type enum value, or INVALID if read fails
             * @note This reads from HkpRigidBody + 0x4C and can be used for early filtering
             */
            Havok::HkcdShapeType GetShapeTypeWrapper() const {
                if (!data()) {
                    return Havok::HkcdShapeType::INVALID;
                }
                uint8_t typeValue = ReadMember<uint8_t>(HavokOffsets::HkpRigidBody::SHAPE_TYPE_WRAPPER, 0xFF);
                return static_cast<Havok::HkcdShapeType>(typeValue);
            }

            /**
             * @brief Get the primitive shape type identifier from the shape object
             * @return Primitive shape type enum value, or INVALID if read fails
             * @note This reads the single byte at shape + 0x10, which is the actual primitive type
             */
            Havok::HkcdShapeType GetShapeType() const {
                if (!data()) {
                    return Havok::HkcdShapeType::INVALID;
                }

                // Read shape pointer at +0x20
                void* shapePtr = nullptr;
                if (!kx::Debug::SafeRead<void*>(data(), HavokOffsets::HkpRigidBody::SHAPE, shapePtr)) {
                    return Havok::HkcdShapeType::INVALID;
                }

                // Validate shape pointer (null check only - SafeRead handles memory safety)
                if (!shapePtr) {
                    return Havok::HkcdShapeType::INVALID;
                }

                // Read primitive shape type from shape + 0x10 (single byte)
                uint8_t typeValue = 0xFF;
                if (!kx::Debug::SafeRead<uint8_t>(shapePtr, HavokOffsets::HkpShapeBase::SHAPE_TYPE_PRIMITIVE, typeValue)) {
                    return Havok::HkcdShapeType::INVALID;
                }

                return static_cast<Havok::HkcdShapeType>(typeValue);
            }

        private:
            // Helper: Read int32 height in centimeters, convert to meters
            float ReadInt32HeightCm(void* shapePtr, uintptr_t offset, int32_t minCm, int32_t maxCm) const {
                int32_t heightCm = 0;
                if (!kx::Debug::SafeRead<int32_t>(shapePtr, offset, heightCm)) {
                    return -1.0f;
                }
                
                if (heightCm < minCm || heightCm > maxCm) {
                    return -1.0f;
                }
                
                return heightCm / 100.0f;
            }

            // Helper: Read float half-extent in game coordinates, convert to full height in meters
            float ReadFloatHeightHalfExtent(void* shapePtr, uintptr_t offset) const {
                float heightHalf = 0.0f;
                if (!kx::Debug::SafeRead<float>(shapePtr, offset, heightHalf)) {
                    return -1.0f;
                }
                
                if (!std::isfinite(heightHalf) || heightHalf <= 0.0f || heightHalf > 10000.0f) {
                    return -1.0f;
                }
                
                float fullHeightMeters = (heightHalf * 2.0f) / 1.23f;
                
                if (fullHeightMeters < 0.1f || fullHeightMeters > 100.0f) {
                    return -1.0f;
                }
                
                return fullHeightMeters;
            }

            // Helper: Read float half-height in meters, convert to full height (no coordinate conversion)
            float ReadFloatHeightHalfMeters(void* shapePtr, uintptr_t offset) const {
                float heightHalf = 0.0f;
                if (!kx::Debug::SafeRead<float>(shapePtr, offset, heightHalf)) {
                    return -1.0f;
                }
                
                if (!std::isfinite(heightHalf) || heightHalf <= 0.0f || heightHalf > 100.0f) {
                    return -1.0f;
                }
                
                float fullHeightMeters = heightHalf * 2.0f;
                
                if (fullHeightMeters < 0.1f || fullHeightMeters > 200.0f) {
                    return -1.0f;
                }
                
                return fullHeightMeters;
            }

            // Helper: Read int32 height directly (no conversion)
            float ReadInt32HeightDirect(void* shapePtr, uintptr_t offset, int32_t min, int32_t max) const {
                int32_t height = 0;
                if (!kx::Debug::SafeRead<int32_t>(shapePtr, offset, height)) {
                    return -1.0f;
                }
                
                if (height < min || height > max) {
                    return -1.0f;
                }
                
                return static_cast<float>(height);
            }

            // Helper: Read vec3 half-extents, validate, and return full extents
            glm::vec3 ReadBoxHalfExtents(void* shapePtr, uintptr_t offset) const {
                glm::vec3 halfExtents(0.0f);
                if (!kx::Debug::SafeRead<glm::vec3>(shapePtr, offset, halfExtents)) {
                    return glm::vec3(0.0f);
                }
                
                if (!std::isfinite(halfExtents.x) || !std::isfinite(halfExtents.y) || !std::isfinite(halfExtents.z)) {
                    return glm::vec3(0.0f);
                }
                
                if (halfExtents.x <= 0.0f || halfExtents.y <= 0.0f || halfExtents.z <= 0.0f) {
                    return glm::vec3(0.0f);
                }
                
                if (halfExtents.x > 10000.0f || halfExtents.y > 10000.0f || halfExtents.z > 10000.0f) {
                    return glm::vec3(0.0f);
                }
                
                glm::vec3 fullExtents = halfExtents * 2.0f;
                fullExtents = fullExtents / 1.23f;
                
                if (fullExtents.x < 0.1f || fullExtents.x > 100.0f ||
                    fullExtents.y < 0.1f || fullExtents.y > 100.0f ||
                    fullExtents.z < 0.1f || fullExtents.z > 100.0f) {
                    return glm::vec3(0.0f);
                }
                
                return fullExtents;
            }

            // Helper: Read cylinder half-height, return height only (width/depth should be derived using WIDTH_TO_HEIGHT_RATIO)
            // Note: GW2 uses the same generic cylinder object everywhere, so all cylinders will be the same size.
            // This means only height information is available from the shape, and width/depth must be derived proportionally.
            glm::vec3 ReadCylinderDimensions(void* shapePtr, uintptr_t heightOffset) const {
                float halfHeight = 0.0f;
                if (!kx::Debug::SafeRead<float>(shapePtr, heightOffset, halfHeight)) {
                    return glm::vec3(0.0f);
                }
                
                if (!std::isfinite(halfHeight) || halfHeight <= 0.0f || halfHeight > 100.0f) {
                    return glm::vec3(0.0f);
                }
                
                float fullHeight = halfHeight * 2.0f;
                
                if (fullHeight < 0.1f || fullHeight > 200.0f) {
                    return glm::vec3(0.0f);
                }
                
                // Return height only - width and depth should be derived using WIDTH_TO_HEIGHT_RATIO in the extractor
                return glm::vec3(0.0f, fullHeight, 0.0f);
            }

            // Helper: Read MOPP shape dimensions by extracting AABB from child shape
            glm::vec3 ReadMoppDimensions(void* moppShapePtr) const {
                // Get the child shape from the MOPP
                HkpMoppBvTreeShape moppShape(moppShapePtr);
                void* childShapePtr = moppShape.GetChildShape();
                if (!childShapePtr) {
                    return glm::vec3(0.0f);
                }
                
                // Read AABB half-extents from the child shape (typically hkpExtendedMeshShape)
                // GetAabbHalfExtents() returns (width, depth, height) in game coordinates
                HkpExtendedMeshShape childShape(childShapePtr);
                glm::vec3 halfExtents = childShape.GetAabbHalfExtents();
                
                // Validate half-extents
                if (halfExtents.x == 0.0f && halfExtents.y == 0.0f && halfExtents.z == 0.0f) {
                    return glm::vec3(0.0f);
                }
                
                if (!std::isfinite(halfExtents.x) || !std::isfinite(halfExtents.y) || !std::isfinite(halfExtents.z)) {
                    return glm::vec3(0.0f);
                }
                
                if (halfExtents.x <= 0.0f || halfExtents.y <= 0.0f || halfExtents.z <= 0.0f) {
                    return glm::vec3(0.0f);
                }
                
                if (halfExtents.x > 100.0f || halfExtents.y > 100.0f || halfExtents.z > 100.0f) {
                    return glm::vec3(0.0f);
                }
                
                // Convert half-extents to full extents
                glm::vec3 fullExtents = halfExtents * 2.0f;
                
                // Convert from game coordinates to meters (same as ReadBoxHalfExtents)
                fullExtents = fullExtents / 1.23f;
                
                if (fullExtents.x < 0.1f || fullExtents.x > 200.0f ||
                    fullExtents.y < 0.1f || fullExtents.y > 200.0f ||
                    fullExtents.z < 0.1f || fullExtents.z > 200.0f) {
                    return glm::vec3(0.0f);
                }
                
                // Map from (width, depth, height) to (width, height, depth) for TryGetDimensions() API
                // halfExtents is (width, depth, height), so fullExtents is also (width, depth, height)
                // Return (width, height, depth) by swapping Y and Z components
                return glm::vec3(fullExtents.x, fullExtents.z, fullExtents.y);
            }

        public:
            /**
             * @brief Type-safe dimension extraction from rigid body shape
             * @return Full dimensions as glm::vec3 (width, height, depth) in meters, or glm::vec3(0.0f) if shape type is unsupported or invalid
             * 
             * Supports CYLINDER, BOX, and MOPP shapes.
             * - CYLINDER: GW2 uses the same generic cylinder object everywhere, so all cylinders will be the same size.
             *   Only height information is available from the shape; width/depth are derived using WIDTH_TO_HEIGHT_RATIO.
             * - BOX: Extracts dimensions directly from the box shape's half-extents.
             * - MOPP: Extracts dimensions from the child shape's cached AABB.
             * All other shape types return glm::vec3(0.0f) to indicate unsupported.
             */
            glm::vec3 TryGetDimensions() const {
                if (!data()) {
                    return glm::vec3(0.0f);
                }

                // Read shape pointer at +0x20
                void* shapePtr = nullptr;
                if (!kx::Debug::SafeRead<void*>(data(), HavokOffsets::HkpRigidBody::SHAPE, shapePtr)) {
                    return glm::vec3(0.0f);
                }

                // Validate shape pointer (null check only - SafeRead handles memory safety)
                if (!shapePtr) {
                    return glm::vec3(0.0f);
                }

                // Read primitive shape type from shape + 0x10 (single byte)
                Havok::HkcdShapeType shapeType = GetShapeType();
                if (shapeType == Havok::HkcdShapeType::INVALID) {
                    return glm::vec3(0.0f);
                }

                // Switch on primitive shape type and extract dimensions from appropriate fields
                switch (shapeType) {
                    case Havok::HkcdShapeType::CYLINDER:
                        return ReadCylinderDimensions(shapePtr, 
                            HavokOffsets::HkpCylinderShape::HEIGHT_HALF_FLOAT);
                    
                    case Havok::HkcdShapeType::BOX:
                        return ReadBoxHalfExtents(shapePtr, HavokOffsets::HkpBoxShape::HALF_EXTENTS);
                    
                    case Havok::HkcdShapeType::MOPP:
                        return ReadMoppDimensions(shapePtr);
                    
                    default:
                        return glm::vec3(0.0f);
                }
            }

            /**
             * @brief Type-safe height extraction from rigid body shape
             * @return Height in meters, or -1.0f if shape type is unsupported or invalid
             * 
             * @deprecated Use TryGetDimensions() for full dimension extraction. This method is kept for backward compatibility.
             * 
             * Supports CYLINDER, BOX, and MOPP shapes.
             * All other shape types return -1.0f to indicate unsupported.
             */
            [[deprecated("Use TryGetDimensions() for full dimension extraction")]]
            float TryGetHeightMeters() const {
                glm::vec3 dimensions = TryGetDimensions();
                if (dimensions.x == 0.0f && dimensions.y == 0.0f && dimensions.z == 0.0f) {
                    return -1.0f;
                }
                return dimensions.y;
            }

            // Deprecated: Unsafe shape casting methods - use TryGetDimensions() instead
            // These methods assume the shape is the expected type without verification
            [[deprecated("Use TryGetDimensions() for type-safe dimension extraction")]]
            HkpCylinderShape GetCylinderShape() const {
                return ReadPointer<HkpCylinderShape>(HavokOffsets::HkpRigidBody::SHAPE);
            }

            [[deprecated("Use TryGetDimensions() for type-safe dimension extraction")]]
            HkpBoxShape GetBoxShape() const {
                return ReadPointer<HkpBoxShape>(HavokOffsets::HkpRigidBody::SHAPE);
            }
        };

    } // namespace ReClass
} // namespace kx
</file>

<file path="ReClass/ItemStructs.h">
#pragma once

#include "../../Utils/SafeForeignClass.h"
#include "../GameEnums.h"
#include "../offsets.h"

namespace kx {
    namespace ReClass {

        /**
         * @brief Wrapper for the game's Item Definition structure.
         * Contains the core properties of an item, like its ID and rarity.
         */
        class ItemDef : public SafeForeignClass {
        public:
            ItemDef(void* ptr) : SafeForeignClass(ptr) {}

            uint32_t GetId() const {
                // Reads the unique item ID (e.g., 49371 for Quiver of Swift Flight).
                // Returns 0 if the read fails.
                return ReadMember<uint32_t>(Offsets::ItemDef::ID, 0);
            }

            Game::ItemRarity GetRarity() const {
                return ReadMember<Game::ItemRarity>(Offsets::ItemDef::RARITY, Game::ItemRarity::None);
            }
        };

    } // namespace ReClass
} // namespace kx
</file>

<file path="ReClass/StatStructs.h">
#pragma once

#include "../../Utils/SafeForeignClass.h"
#include "../offsets.h"

namespace kx {
    namespace ReClass {

        /**
         * @brief Wrapper for the game's Stat structure.
         * Contains the ID for an item's attribute combination (e.g., Berserker's).
         */
        class Stat : public SafeForeignClass {
        public:
            Stat(void* ptr) : SafeForeignClass(ptr) {}

            uint32_t GetId() const {
                // Reads the stat combination ID (e.g., 599 for Berserker's).
                // Returns 0 if the read fails.
                return ReadMember<uint32_t>(Offsets::Stat::ID, 0);
            }
        };

    } // namespace ReClass
} // namespace kx
</file>

<file path="ReClassStructs.h">
#pragma once

/**
 * @file ReClassStructs.h
 * @brief Main header that includes all ReClass structure modules
 * 
 * This file serves as the entry point for all ReClass game structure wrappers.
 * The structures have been organized into logical modules for better maintainability:
 * 
 * - AgentStructs.h: Agent and coordinate wrappers for character entities
 * - CharacterStructs.h: Character, health, stats, energies, and player wrappers
 * - HavokStructs.h: Havok physics engine wrapper classes
 * - GadgetStructs.h: Gadget, agent, and coordinate wrappers for world objects
 * - ContextStructs.h: Context managers and the root context collection
 */

#include "ReClass/AgentStructs.h"     // Must be included first (no dependencies)
#include "ReClass/CharacterStructs.h" // Depends on AgentStructs
#include "ReClass/HavokStructs.h"     // Havok physics wrappers (independent)
#include "ReClass/GadgetStructs.h"    // Depends on HavokStructs
#include "ReClass/EquipmentStructs.h"
#include "ReClass/ContextStructs.h"   // Depends on Character and Gadget structs
</file>

</files>
